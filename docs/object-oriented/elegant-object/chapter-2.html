<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VJSDQ25SYT"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-VJSDQ25SYT",{})</script><title data-react-helmet="true">🌈 Chapter 2: Education | Summary of Books</title><meta data-react-helmet="true" property="og:url" content="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🌈 Chapter 2: Education | Summary of Books"><meta data-react-helmet="true" name="description" content="🦄 가능하다면 적게 캡슐화하세요"><meta data-react-helmet="true" property="og:description" content="🦄 가능하다면 적게 캡슐화하세요"><link data-react-helmet="true" rel="shortcut icon" href="/reading_books_record_repository/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2"><link data-react-helmet="true" rel="alternate" href="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2" hreflang="x-default"><link rel="stylesheet" href="/reading_books_record_repository/assets/css/styles.cefedd52.css">
<link rel="preload" href="/reading_books_record_repository/assets/js/runtime~main.3025a413.js" as="script">
<link rel="preload" href="/reading_books_record_repository/assets/js/main.4307086f.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/reading_books_record_repository/"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Summary of Books</b></a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/functional/table-of-contents">함수형</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/test/table-of-contents">테스트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/etc/table-of-contents">기타</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/reading_books_record_repository/"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Summary of Books</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/functional/table-of-contents">함수형</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/test/table-of-contents">테스트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/etc/table-of-contents">기타</a></li><li class="menu__list-item"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/intro">책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">코어 자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-1">🌈 Chapter 1: 데이터 타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-2">🌈 Chapter 2: 실행 컨텍스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-3">🌈 Chapter 3: this</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-4">🌈 Chapter 4: 콜백 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-5">🌈 Chapter 5: 클로저</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-6">🌈 Chapter 6: 프로토타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-7">🌈 Chapter 7: 클래스</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">자바스크립트 코딩의 기술</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-1">1. 변수 할당으로 의도를 하라</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-2">2. 배열로 데이터 컬렉션을 관리하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-3">3. 특수한 컬렉션을 이용해 코드 명료성을 극대화하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-4">4. 조건문을 깔끔하게 작성하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-5">5. 반복문을 단순하게 만들어라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-6">6. 매개변수와 return 문을 정리하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-7">7. 유연한 함수를 만들어라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-8">8. 클래스로 인터페이스를 간결하게 유지하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-9">9. 외부 데이터에 접근하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-10">10. 컴포넌트 아키텍처를 이용해 관련 파일을 모아라.</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">자바스크립트 패턴과 테스트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-1">🌈 Chapter 1: 좋은 소프트웨어 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-2">🌈 Chapter 2: 도구 다루기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-3">chapter-3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-4">🌈 Chapter 4: 패턴이 좋은 점</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-5">🌈 Chapter 5: 콜백 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-6">🌈 Chapter 6: 프라미스 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-7">🌈 Chapter 7: 부분 적용 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-8">🌈 Chapter 8: 메모이제이션 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-9">🌈 Chapter 9: 싱글톤 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-10">🌈 Chapter 10: 팩토리 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-11">🌈 Chapter 11: 샌드박스 패턴</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">타입스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Do it! 타입스크립트 프로그래밍</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-1">1. 타입스크립트와 개발 환경 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-2">2. 타입스크립트 프로젝트 생성과 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-3">3. 객체와 타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-4">4. 함수와 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-5">5. 배열과 튜플</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-6">6. 반복기 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-7">7. Promise와 async/await 구문</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-8">8. 함수 조합의 원리와 응용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-9">9. 람다 라이브러리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-10">10. 제네릭 타입 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-11">11. 모나드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-12">12. 타입스크립트 함수형 프로그래밍 실습</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">이펙티브 타입스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/effective-typescript/table-of-contents">table-of-contents</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/effective-typescript/chapter-1">1. 타입스크립트 알아보기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">애자일</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">클린 애자일</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-1">👉 Chapter 1: 애자일 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-2">👉 Chapter 2: 왜 애자일인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-3">👉 Chapter 3: 비즈니스 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-4">👉 Chapter 4: 팀 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-5">👉 Chapter 5: 기술 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-6">👉 Chapter 6: 애자일해지기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-7">👉 Chapter 7: 장인 정신</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">린 UX</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-1">🌈 왜 린 UX인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-2">🌈 기본 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-3">🌈 비전 정의와 실행 계획, 성과</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-4">🌈 협업기반 디자인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-5">🌈 MVP와 실험</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-6">🌈 조사와 피드백</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-7">🌈 애자일과 린 UX의 통합</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-8">🌈 조직 변화 만들기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">The Nature of Software Development</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-1">1. 가치 찾기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-2">2. 가치, 우리가 원하는 것</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-3">3. 피처 단위 개발을 위한 가이드라인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-4">4. 피처 단위로 조직 구성하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-5">5. 피처 단위로 계획하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-6">6. 피처 단위로 개발하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-7">7. 피처와 기반을 동시에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-8">8. 무결점과 견고한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-9">9. 요약</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-10">10. 가치에 대해서</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-11">11. 가치를 정하는 기준</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-12">12. 물론 힘들 일입니다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-13">13. 그리 단순하지 않습니다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-14">14. 성장하는 개발팀 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-15">15. 초기 계획을 위한 &#x27;파이브 카드&#x27;</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-16">16. 경영진을 위한 소프트웨어 개발의 본질</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-17">17. 더 강한 채찍질</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-18">18. 속도를 내기 위한, 특별한 빌드 기술</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-19">19. 리팩토링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-20">20. 애자일 방법들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-21">21. 애자일 확장</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">함께 자라기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-1">🌈 Chapter 1: 자라기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-2">🌈 Chapter 2: 함께</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-3">🌈 Chapter 3: 애자일</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">객체지향</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-1">🌈 Chapter 1: 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-2">🌈 Chapter 2: 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-3">🌈 Chapter 3: 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-4">🌈 Chapter 4: 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-5">🌈 Chapter 5: 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-6">🌈 Chapter 6: 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-7">🌈 Chapter 7: 함께 모으기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-1">🌈 Chapter 1: 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-2">🌈 Chapter 2: 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-3">🌈 Chapter 3: 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-4">🌈 Chapter 4: 설계 품질과 트레이드오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-5">🌈 Chapter 5: 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-6">🌈 Chapter 6: 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-7">🌈 Chapter 7: 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-8">🌈 Chapter 8: 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-9">🌈 Chapter 9: 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-10">🌈 Chapter 10: 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-11">🌈 Chapter 11: 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-12">🌈 Chapter 12: 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-13">🌈 Chapter 13: 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-14">🌈 Chapter 14: 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-15">🌈 Chapter 15: 디자인 패턴과 프레임워크</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">루비로 배우는 객체지향 디자인</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-1">✌️ Chapter 1: 객체지향 디자인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-2">✌️ Chapter 2: 단일 책임 원칙을 따르는 클래스 디자인하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-3">✌️ Chapter 3: 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-4">✌️ Chapter 4: 유연한 인터페이스 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-5">✌️ Chapter 5: 오리 타입으로 비용 줄이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-6">✌️ Chapter 6: 상속을 이용해 새로운 행동 얻기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-7">✌️ Chapter 7: 모듈을 통한 역할 공유</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-8">✌️ Chapter 8: 조합을 이용해 객체 통합하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-9">✌️ Chapter 9: 비용-효율적인 테스트 디자인하기</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">엘레강트 오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-1">🌈 Chapter 1: Birth</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2">🌈 Chapter 2: Education</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3">🌈 Chapter 3: Employment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-4">🌈 Chapter 4: Retirement</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">함수형</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">스칼라로 배우는 함수형 프로그래밍</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-1">🍭 Chapter 1: 함수형 프로그래밍이란 무엇인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-2">🍭 Chapter 2: 스칼라로 함수형 프로그래밍 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-3">🍭 Chapter 3: 함수적 자료구조</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-4">🍭 Chapter 4: 예외를 이용하지 않은 오류 처리</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">함수형 자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/chapter-1">🌈 Chapter 1: 함수형 길들이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/chapter-7">🌈 Chapter 7: 함수형 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/chapter-8">🌈 Chapter 8: 비동기 이벤트와 데이터를 관리</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">클린코드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">클린 코드: 애자일 소프트웨어 장인 정신</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-1">🍭 Chapter 1: 깨끗한 코드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-2">🍭 Chapter 2: 의미있는 이름</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-3">🍭 Chapter 3: 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-4">🍭 Chapter 4: 주석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-5">🍭 Chapter 5: 형식 맞추기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-6">🍭 Chapter 6: 객체와 자료 구조</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-7">🍭 Chapter 7: 오류 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-8">🍭 Chapter 8: 경계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-9">🍭 Chapter 9: 단위 테스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-10">🍭 Chapter 10: 클래스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-11">🍭 Chapter 11: 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-12">🍭 Chapter 12: 창발성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-13">🍭 Chapter 13: 동시성</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">테스트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">테스트 주도 개발로 배우는 객체 지향 설계와 실천</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-1">1. 테스트 주도 개발의 핵심은 무엇인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-2">2. 객체를 활용한 테스트 주도 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-3">3. 도구 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-4">4. 테스트 주도 주기 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-5">5. 테스트 주도 개발 주기의 유지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-6">6. 객체 지향 스타일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-7">7. 객체 지향 설계의 달성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-8">8. 서드 파티 코드를 기반으로 한 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-9">9. 경매 스나이퍼 개발 의뢰</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-10">10. 동작하는 골격</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-11">11. 첫 테스트 통과하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-12">12. 입찰 준비</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-13">13. 스나이퍼가 입찰하다</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-14">14. 스나이퍼가 경매에서 낙찰하다</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-15">15. 실제 사용자 인터페이스를 향해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-16">16. 여러 품목에 대한 스나이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-17">17. Main 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-18">18. 세부 사항 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-19">19. 실패 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-20">20. 테스트에 귀 기울이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-21">21. 테스트 가독성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-22">22. 복잡한 테스트 데이터 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-23">23. 테스트 진단</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/growing-object-oriented-software-guided-by-tests/chapter-24">24. 테스트 유연성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">테스트 주도 개발</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/test-driven-development/table-of-contents">🚀 목차</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">단위 테스트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/test/unt-test/table-of-contents">🚀 목차</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">기타</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-1">🤔 Chapter 1: 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-2">🤔 Chapter 2: 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-3">🤔 Chapter 3: 기본 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-4">🤔 Chapter 4: 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-5">🤔 Chapter 5: 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-6">🤔 Chapter 6: 동시성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-7">🤔 Chapter 7: 코딩하는 동안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-8">🤔 Chapter 8: 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-9">🤔 Chapter 9: 실용주의 프로젝트</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">인스파이어드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/inspired/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/inspired/part-1">👉 Part 1. 최고의 기술 기업에서 배운 것</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/inspired/part-2">👉 Part 2. 사람</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Pro Git 2판</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/chapter-1">🌈 Chapter 1: 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/chapter-2">🌈 Chapter 2: Git의 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/chapter-3">🌈 Chapter 3: Git 브랜치</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">🌈 Chapter 2: Education</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-가능하다면-적게-캡슐화하세요"></a>🦄 가능하다면 적게 캡슐화하세요<a class="hash-link" href="#-가능하다면-적게-캡슐화하세요" title="Direct link to heading">#</a></h3><ul><li>복잡성이 높을수록 유지보수성이 저하되고, 시간과 돈이 낭비되며, 고객 만족도가 떨어진다. 때문에 4개 또는 그 이하의 객체를 캡슐화할 것을 권장한다.</li><li>내부에 캡슐화된 객체 전체를 가리켜 객체의 상태 또는 식별자라고 부른다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 3개의 객체를 캡슐화하고 있다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Integer digits;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Integer cents;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private String currency;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>동일한 값의 달러, 센트, 통화를 캡슐화하는 <code>Cash</code> 클래스의 두 객체는 서로 동일하다는 뜻이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash x = new Cash(29, 95, &quot;USD&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash y = new Cash(29, 95, &quot;USD&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert x.equals(y);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert x == y;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 예제는 두 객체 <code>x</code>와 <code>y</code>의 상태는 동일하지만 식별자는 서로 다르다. <code>==</code>연산자와 <code>equals</code>로 두 객체가 서로 동일하지 않다고 판단한다.</li><li>Java를 비롯한 OOP 언어에서 객체는 단지 메서드가 추가된 데이터의 집합일 뿐이다. 데이터의 저장 여부와 상관없이 복사본을 비교하는 경우에도 다르다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Object x = new Object();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Object y = new Object();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert x.equals(y); // 실패</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>내부에 캡슐화된 모든 객체들이 객체의 식별자를 구성하는 요소라는 사실에 동의한다면, 이제 캡슐화하기에 적합한 객체의 수를 결정해야 한다.</li><li>최대 4개가 합리적인 이유는 4개 이상의 자표는 직관에 위배된다는 사실이다.(사람은 이름, 생년월일 / 자동차는 제조사, 모델, 제조년도)</li><li>더 많은 객체가 필요하다면, 클래스를 더 작은 클래스들로 분해해야 한다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-최소한-뭔가는-캡슐화하세요"></a>🦄 최소한 뭔가는 캡슐화하세요<a class="hash-link" href="#-최소한-뭔가는-캡슐화하세요" title="Direct link to heading">#</a></h3><ul><li>다음 예는 캡슐화를 하지 않은 객체이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Year {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int read() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return System.currentTimeMillis()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>프로퍼티가 없는 클래스는 객체지향 프로그래밍에서 정적 메서드와 유사하다. 이런 클래스는 아무런 상태와 식별자도 가지지 않고 오직 행동만을 포함한다.</li><li>실행으로부터 인스턴스 생성을 고립시켜야 한다. 다시 말해서 오직 <code>constructor</code>에서만 <code>new</code>연산자를 허용해야 한다는 뜻이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Year {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Millis millis;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Year(Millis msec) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.millis = msec;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int read() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.millis.read()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>객체는 무언가를 캡슐화해야 한다. 이 객체는 자기 자신을 식별할 수 있도록 다른 객체들을 캡슐화해야 한다.</li><li>만약 객체가 어떤 것도 캡슐화하지 않는다면 객체의 좌표는 객체 자신이 세계 전체가 되어야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Universe {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>오직 하나의 세계만 존재할 수 있기 때문에 이 클래스는 오직 하나만 존재해야 한다.</li><li>다음 예제는 완벽한 객체지향 설계를 적용한 모습이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Year {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Number num;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Year(final Millis msec) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.num = new Min(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Div(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        msec,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Mul(1000, 60, 60, 24, 30, 12)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      1970</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int read() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.num.intValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>또는 다음과 같다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Year {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Number num;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Year(final Millis msec) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.num = msec.div(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      1000.mul(60).mul(60).mul(24).mul(30).mul(12)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ).min(1970);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int read() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.num.intValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-항상-인터페이스를-사용하세요"></a>🦄 항상 인터페이스를 사용하세요.<a class="hash-link" href="#-항상-인터페이스를-사용하세요" title="Direct link to heading">#</a></h3><ul><li>객체들은 서로를 필요로 하기 때문에 <strong>결합</strong>된다는 것이다.</li><li>설계를 시작하는 단계에서 각각의 객체가 어떤 일을 수행해야 하고 다른 객체에게 어떤 서비스를 제공하는 지를 정확하고 알고 있는 편이 낫기 때문에 결합은 유용하지만 객체의 수가 수십 개를 넘거가면서부터 객체 사이의 강한 결합도의 문제가 발생하게 된다.</li><li>애플리케이션 전체를 유지보수 가능하도록 만들기 위해서는 객체를 <strong>분리해야한다.</strong></li><li>객체 분리란 상호작용하는 <strong>다른 객체를 수정하지 않고도</strong> 해당 객체를 수정할 수 있도록 만든다는 것을 의미한다. 이를 가능하게 하는 도구가 바로 <strong>인터페이스</strong>이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Cash multiply(float factor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Cash</code>는 인터페이스로 객체가 다른 객체와 의사소통하기 위해 따라야하는 <strong>계약</strong>이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class DefaultCash implements Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  DefaultCash(int dlr) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars = dlr;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 계약에 의존</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Cash multiply(float factor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DefaultCash(this.dollars * factor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>금액이 필요하다면 실제 구현 대신 계약에 의존하면 된다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Employee {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Cash salary;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Employee</code> 클래스는 <code>Cash</code> 인터페이스의 구현 방법에 아무런 관심이 없다. 어떻게 동작하는 지도 관심없다. 때문에 느슨하게 분리할 수 있다.</li><li>추가로 클래스 안의 <strong>모든</strong> 퍼블릭 메서드가 인터페이스를 구현하도록 만들어야 한다. 올바르게 설계된 클래스라면 <strong>최소한 하나의 인터페이스라도 구현하지 않는 퍼블릭 메서드를 포함해서는 안된다.</strong></li><li>다음과 같이 설계해서는 안된다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int cents() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 어떤 작업을 수행</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>cents</code> 메서드는 어떤 것도 오버라이드하지 않기 때문에 문제가 있다. 이 설계는 클래스의 사용자로 하여금 이 클래스에 강하게 결합되도록 조장한다. 다른 클래스의 객체가 직접적으로 <code>Cash.cents()</code>를 사용할 수 밖에 없기 때문에 새로운 메서드를 이용해서 구현을 대체할 수 없다.</li><li>클래스가 존재하는 이유는 <strong>다른 누군가가 클래스의 서비스를 필요</strong>로 하기 때문이고, 서비스는 계약이자 인터페이스이기 때문에 클래스가 제공하는 서비스는 어딘가에 문서화되어야 한다.</li><li>동일한 인터페이스를 구현하는 여러 클래스들이 존재한다. 그리고 각각의 경쟁자는 서로 다른 경쟁자를 쉽게 대체할 수 있어야 한다. 이것이 <strong>느슨한 결합도</strong>의 의미이다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-메서드-이름을-신중하게-선택하세요"></a>🦄 메서드 이름을 신중하게 선택하세요<a class="hash-link" href="#-메서드-이름을-신중하게-선택하세요" title="Direct link to heading">#</a></h3><ul><li>간단한 법칙은 빌더(builder)의 이름은 <strong>명사</strong>로, 조정자(manipulator)의 이름은 <strong>동사</strong>로 짓는 것이다.</li><li>빌더란 뭔가를 만들고 새로운 객체를 반환하는 메서드를 가리킨다. 빌더는 항상 <strong>뭔가를 반환해야 한다.</strong> 빌더의 반환타입은 절대 <code>void</code>가 될 수 없으며, 이름은 항상 명사여야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int pow(int base, int power);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">float speed();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Employee employee(int id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">String parsedCell(int x, int y); // 형용사인 parsed가 명사인 cell을 꾸미고 있을 뿐 명사다.</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>객체로 추상화한 실세계 엔티티를 수정하는 메서드를 조정자라고 부른다. 조정자의 반환 타입은 항상 <code>void</code>이고, 이름은 항상 <strong>동사</strong>이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void save(String content);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void put(String key, Float value);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void remove(Employee emp);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">void quicklyPrint(int id); // 부사의 꾸밈을 받는 동사</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음은 원칙을 위반하는 잘못된 예</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 저장된 전체 바이트를 반환</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int save(String content); // void를 반환하도록 바꾸거나 bytesSaved()와 같은 이름으로 변경</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// map이 변경된 경우 TRUE를 반환 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean put(String key, Float value); // void를 반환하도록 변경하거나 putOperation으로 변경</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// speed를 저장한 후 이전 값을 반환</span></span><span class="token-line" style="color:#393A34"><span class="token plain">float speed(float val);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-빌더는-명사다"></a>🎈 빌더는 명사다<a class="hash-link" href="#-빌더는-명사다" title="Direct link to heading">#</a></h4><ul><li>어떤 갓을 반환하는 메서드의 이름을 동사로 짓는 것은 잘못이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Bakery {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Food cookBrownie();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Drink brewCupOfCoffee(String flavor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위의 두 메서드는 객체의 메서드가 아니라 <strong>프로시저</strong>이다.</li><li>두 메서드의 이름은 <code>Bakery</code>를 자립적이고 자율적인 객체로 존중해서는 안되기 때문에 객체에게 할 일을 일일이 명령해야 한다고 속삭인다. 이것은 객체지향적인 접근방법이 아니라 절차적인 접근방법이다.</li><li>메서드의 이름을 동사로 지을 때에는 객체에게 무엇을 할 지를 알려주어야 한다. 무엇을 만들어야 하는 지만 요청하고, 만드는 방법은 객체 스스로 결정하도록 해야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 잘 지어진 예</span></span><span class="token-line" style="color:#393A34"><span class="token plain">InputStream stream(URL url);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">String content(File file);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int sum(int x, int y);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-조정자는-동사다"></a>🎈 조정자는 동사다<a class="hash-link" href="#-조정자는-동사다" title="Direct link to heading">#</a></h4><ul><li>실세계의 엔티티를 조작해야 하는 경우에는, 다음과 같이 객체가 그 작업을 수행하도록 요청한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Pixel {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void paint(Color color);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Pixel center = new Pixel(50, 50);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">center.paint(new Color(&quot;red&quot;));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>paint</code> 메서드는 값을 반환하지 않는다. 요청하는 것과 같다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-빌더와-조정자-혼합하기"></a>🎈 빌더와 조정자 혼합하기<a class="hash-link" href="#-빌더와-조정자-혼합하기" title="Direct link to heading">#</a></h4><ul><li>다음 예는 파일 내용을 저장하고 저장된 바이트 수를 반환하는 메서드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Document {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int write(InputStream content);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 메서드는 앞에서 설명한 원칙을 위반하고 있다. 원칙상으로는 메서드 <code>write</code>의 반홚 타입을 <code>void</code>로 바꿔야 하지만, 실제로 저장된 바이트 수를 알 필요가 있다.</li><li><code>write()</code> 메서드는 데이터를 쓰는 동시에, 쓰여진 바이트 수를 카운트한다. 다시 말해서 하나의 메서드 안에서 너무 복잡한 일을 처리하고 있다. 메서드의 목적이 명확하지 않기 때문에 깔끔하게 명사나 동사 둘 중 하나로 이름을 지을 수가 없다. 이 문제를 해결할 방법으로 리팩토링을 해야한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Document {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  OutputPipe output(); // 빌더</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class OutputPipe {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void write(InputStream content); // 조정자</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int bytes(); // 빌더</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  long time(); // 빌더</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-boolean-값을-결과로-반환하는-경우"></a>🎈 Boolean 값을 결과로 반환하는 경우<a class="hash-link" href="#-boolean-값을-결과로-반환하는-경우" title="Direct link to heading">#</a></h4><ul><li><code>Boolean</code> 값을 반환하는 메서드의 이름은 어떻게 지을까?</li><li><code>Boolean</code> 값을 반환하는 메서드는 규칙에 있어서 예외적인 경우이다. 값을 반환하기 때문에 이 메서드들은 빌더에 속하지만, 가독성 측면에서 이름을 <strong>형용사</strong>로 지어야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">boolean empty(); // is empty</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean readable(); // is readable</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean negative(); // is negative</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>접두사 <code>is</code>는 중복이기 때문에 메서드의 이름에 포함시키지 않지만, 메서드를 읽을 때는 일시적으로 앞에 붙여 자연스벌게 들리도록 해야 한다.</li><li>아래의 메서드에서는 문제가 될 수 있는데 <code>is</code>를 붙이면 올바르지 않은 문장이 만들어지기 때문이다. 이런 경우 더 적합한 이름은 <code>equalTo</code>와 <code>present</code>이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">boolean equals(Object obj);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean exists();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Boolean</code>을 반환하는 메서드를 특별하게 취급해야 하는 이유는 Java를 포함한 대부분의 언어들이 논리 구성자를 특별한 방식으로 다루기 때문이다.</li><li>다음은 클래스에 문자열이 비어있는지 여부를 반환하는 <code>emptiness()</code> 메서드를 추가한 후 사용한 것이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">if (name.emptiness() == true) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 뭔가 한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 문장은 <code>if emptiness of the name is true</code>로 자연스럽게 읽히지만 Java에서는 이런 방식으로 코드를 작성하지 않는다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">if (name.empty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 뭔가 한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>요약하지면, <strong>먼저 메서드의 목적이 무엇인지를 확인하고, 메서드는 빌더나 조정자, 둘 중 하나여야 한다. 절대로 빌더인 동시에 조정자이면 안된다. 빌더는 명사로, 조정자는 동사로 지어야 한다.</strong></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-퍼블릭-상수public-constant를-사용하지-마세요"></a>🦄 퍼블릭 상수(Public Constant)를 사용하지 마세요<a class="hash-link" href="#-퍼블릭-상수public-constant를-사용하지-마세요" title="Direct link to heading">#</a></h3><ul><li>상수라고도 불리는 <code>public static final</code> 프로퍼티는 객체 사이에 데이터를 공유하기 위해 사용하는 메커니즘이다. 글자 그대로 상수를 사용하는 아유는 데이터를 공유하기 위해서이다.</li><li>하지만 반대하는 이유 또한 객체들은 어떤 것도 공유해서는 안되기 때문이다. 대신 독립적이어야하고 닫혀 있어야 한다.</li><li>상수를 이용한 공유 메커니즘은 캡슐화와 객체지향적인 사고 전체를 부정하는 일이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Records {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static final String EOL = &quot;\r\n&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void write(Writer out) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Record rec: this.all) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.write(rec.toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.write(Records.EOL);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 예제는 <code>Recodes</code> 클래스의 내부에서만 사용되므로 완전히 울바른 상황이다. 하지만 다른 객체를 사용하는 <code>Rows</code> 클래스가 있다면?</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Rows {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static final String EOL = &quot;\r\n&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void print(PrintStream pnt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Row row: this.fetch()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      pnt.printf(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;{ %s }%s&quot;, row, Rows.EOL</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Rows</code>의 로직은 <code>Records</code>의 로직과 다르며, 협력하는 객체 집합도 완전히 다르다. 두 클래스는 공통점이 없다. 하지만 두 클래스 모두 <code>EOL</code> <code>private</code> 상수를 정의하고 있다. 때문에 다음과 같이 객체를 사용해서 중복 문제를 해결해야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Constants {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static final String EOL = &quot;\r\n&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이렇게 하면 <code>public</code>이끼 때문에 클래스 로더에 의해 로딩된 모든 클래스들이 상수에 접근할 수 있다. 퍼블릭 상수를 재사용할 수 있다.</li><li>하지만 <strong>결합도</strong>가 높아졌고 <strong>응집도</strong>가 낮아졌다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-결합도-증가"></a>🎈 결합도 증가<a class="hash-link" href="#-결합도-증가" title="Direct link to heading">#</a></h4><ul><li>다음은 <code>Records</code> 클래스와 <code>Rows</code> 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Records {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void write(Writer out) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Record rec: this.all) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.write(rec.toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.write(Constants.EOL); // here!</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class Rows {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void print(PrintStream pnt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Row row: this.fetch()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      pnt.printf(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;{ %s }%s&quot;, row, Constants.EOL // here!</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>두 클래스는 모두 같은 객체에 의존하고 있으며 이 의존성은 <strong>하드 코딩</strong>되어 있다.</li><li><code>Records.write()</code>, <code>Rows.print()</code>, <code>Constants,EOL</code> 세 곳에서 코드의 일부가 서로 결합되어 의존하고 있다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-응집도-저하"></a>🎈 응집도 저하<a class="hash-link" href="#-응집도-저하" title="Direct link to heading">#</a></h4><ul><li>퍼블릭 상수를 사용하면 객체의 응집도는 낮아진다. 낮은 응집도는 객체가 자신의 문제를 해결하는데 덜 집중한다는 것을 의미한다.</li><li>상수는 자신에 관해 아무 것도 알 지 못하며, 자신의 존재 이유를 이해하지 못하는 하나의 텍스트 덩어리에 불과하다.</li><li>의미를 추가하기 위해서는 <code>Records</code>와 <code>Rows</code> 클래스 안에 더 많은 코드를 작성해야 한다. 목적을 명확하게 만들어줄 코드를 추가해서 이 원시적인 정적 상수를 감싸야 한다. 하지만 이런 코드는 원래 의도했던 목적과 동떨어져 있을 수 밖에 없다.</li><li>때문에 코드 중복 문제를 적절하게 해결하기 위해서는 객체 사이에 데이터를 중복해서는 안된다. 대신, <strong>기능을 공유</strong>할 수 있도록 <strong>새로운 클래스</strong>를 만들어야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 기능을 공통으로 제공한 새로운 클래스를 추가</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class EOLString {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final String origin;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  EOLString(String src) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.origin = src;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  String toString() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return String.format(&quot;%S\r\n&quot;, origin);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이제 필요한 곳에서 <code>EOLString</code>을 사용할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Records {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void write(Writer out) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Record rec: this all) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      out.write(new EOLString(rec.toString()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class Rows {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void print(PrintStream pnt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Row row: this.fetch()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      pnt.printf(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        new EOLString(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          String.format(&quot;{ %s }&quot;, row)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이제 접미사를 줄 마지막에 정확하게 추가하는 방법에 관해서는 <code>EOLString</code>이 책임을 진다.</li><li><code>EOLString</code>에 대한 결합은 <strong>계약을 통해</strong> 추가된 것이며, 계약에 의한 결합은 언제라도 분리가 가능하기 때문에 유지보수성으 저하시키지 않는다.</li><li>요약하자면 <strong>OOP에서 퍼블릭 상수를 절대로 사용해서는 안된다.</strong> 사소해 보이는 상수라도 항상 작은 클래스를 이영해서 대체해야 한다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-불변-객체로-만드세요"></a>🦄 불변 객체로 만드세요<a class="hash-link" href="#-불변-객체로-만드세요" title="Direct link to heading">#</a></h3><ul><li>모든 클래스를 상태 변경이 불가능한 불변 클래스(immutable class)로 구현하면 유지보수성을 크게 향상시킬 수 있다.</li><li>불변성은 크기가 작고, 응집력이 높으며, 느슨하게 결합되고, 유지보수하기 쉬운 클래스를 만들 수 있도록 한다.</li><li><strong>인스턴스를 생성한 후에 상태를 변경할 수 없는 객체를 불변 객체</strong>라고 부른다.</li><li>다음 예는 가변 객체이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setDollars(int val) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars = val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음 예제는 불변 객체이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Cash(int val) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars = val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>final</code> 키워드는 생성자 외부에서 프로퍼티의 값을 수정할 경우 컴파일 타임 에러가 발생해야 한다는 사실을 컴파일러에게 알려준다.</li><li>불변 객체는 필요한 모든 것을 내부에 캡슐화하고 변경할 수 없도록 통제한다. 불변 객체를 수정해야 한다면 프로퍼티를 수정하는 대신 새로운 객체를 생성해야 한다.</li><li>다음은 가변 클래스로 구현한 코드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void mul(int factor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars *= factor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음은 동일한 작업을 수행하는 불변 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Cash mul(int factor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Cash(this.dollars * factor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>불변 객체는 자기 자신을 수정할 수 없고 <strong>항상 원하는 상태를 가지는 새로운 객체를 생성해서 반환해야 한다.</strong></li><li>다음은 가변 객체의 사용 방법</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash five = new Cash(5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">five.mul(10);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(five); // 50</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음은 불변 객체를 사용한 방법이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash five = new Cash(5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash fifty = five.mul(10);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(fifty); // 50</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>five</code> 객체를 생성하고 나면 <code>five</code>는 <code>fifty</code>가 될 수 없다. 5는 5일 뿐이다.</li><li><strong>가변 객체는 엄격하게 금지해야 한다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-식별자-가변성identity-mutability"></a>🎈 식별자 가변성(Identity Mutability)<a class="hash-link" href="#-식별자-가변성identity-mutability" title="Direct link to heading">#</a></h4><ul><li>불변 객체에는 식별자 가변성 문제가 없다. 이 문제는 동일해 보이는 두 객체를 비교한 후 한 객체의 상태를 변경할 때 문제가 발생하는데, 더 이상 동일하지 않지만, 여전히 두 객체가 동일하다고 생각한다. 그 반대일 수도 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;Cash, String&gt; map = new HashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash five = new Cash(&quot;$5&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash ten = new Cash(&quot;$10&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">map.put(five, &quot;five&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">map.put(ten, &quot;ten&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">five.mul(2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(map); // { $10 =&gt; &quot;five&quot;, $10 =&gt; &quot;ten&quot; }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이러면 <code>map</code>은 동일한 키가 두 개 존재하기 때문에 올바르지 않다. 처음엔 동일하지 않은 두 객체를 생성한 뒤 두 객체를 <code>map</code>에 추가하는데, 이때는 키가 서로 다르기 때문에 <code>HashMap</code>은 두 개의 독립적인 엔트리를 생성한다. 그 후 5를 10으로 변경해도 <code>map</code>에게 이 사실을 알려주지 않았기 때문에 <code>map</code>은 변경이 일어났다는 사실을 전혀 인식하지 못한다.</li><li>이 후 둘 중 하나를 검색하려고 하면, <code>map</code> 상태가 비정상적이기 때문에 어떤 결과를 얻을지 예측할 수 없다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">map.get(five) // ten? five??</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>불변 객체를 사용하면 객체를 <code>map</code>에 추가한 후에는 상태 변경이 불가능하기 때문에 식별자 가변성 문제가 발생하지 않는다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-실패-원자성failure-atomicity"></a>🎈 실패 원자성(Failure Atomicity)<a class="hash-link" href="#-실패-원자성failure-atomicity" title="Direct link to heading">#</a></h4><ul><li>실패 원자성이란 <strong>완전하고 견고한 상태의 객체</strong>를 가지거나 아니면 <strong>실패하거나</strong> 둘 중 하나만 가능한 특성이다.</li><li>다음은 가변 클래스 <code>Cash</code> 예제이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int cents;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void mul(int factor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars *= factor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (/* 뭔가 잘못 됐다면 */) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw new RuntimeException(&quot;oops...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.cents *= factor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>mul()</code> 메서드를 실행하는 도중에 예외가 던져진다면 객체의 절반(<code>this.dollars</code>)만 수정되고 나머지 절반(<code>this.cents</code>)은 원래 값을 유지한다.</li><li>불변 객체는 내부의 어떤 것도 수정할 수 없기 때문에 이런 결함이 발생하지 않는다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int cents;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Cash mul(int factor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (/* 뭔가 잘못 됐다면 */) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw new RuntimeException(&quot;oops...&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Cash(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.dollars * factor,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.cents * factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>불변 객체의 정의에 따르면 모든 불변 객체는 <strong>원자적</strong>이기 때문에 원자성을 걱정할 필요가 없다.</li><li>가변 객체 안에서 명시적으로 실패 원자성을 보장하는 방법도 있지만 객체의 복잡성이 더 높아지고, 실수할 가능성이 더 커지기 때문에 좋지 않다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-시간적-결합temporal-coupling"></a>🎈 시간적 결합(Temporal Coupling)<a class="hash-link" href="#-시간적-결합temporal-coupling" title="Direct link to heading">#</a></h4><ul><li>다음은 시간적 결합을 이해할 수 있는 좋은 방법인 예제이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash price = new Cash();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">price.setDollars(29);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">price.setCents(95);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(price); // &quot;$29.95&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>각 줄은 특정한 순서로 정렬되어 있다. 각 줄은 시간적인 순서에 따라 서로 결합되어 있다. 다음과 같이 코드를 재정렬해도 컴파일은 여전히 성공한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash price = new Cash();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">price.setDollars(29);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(price); // &quot;$29.00&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">price.setCents(95);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이렇게 줄 사이의 시간적인 결합을 프로그래머가 기억해야 한다. 이러면 유지보수에 있어서 어려움이 크다.</li><li>다음과 같이 불변 객체를 이용하여 문제를 해결할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash price = new Cash(29, 95);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(price); // &quot;$29.95&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이렇게 하나의 문장으로 객체를 인스턴스화할 수 있다. 이 경우에는 <strong>인스턴스화</strong>와 <strong>초기화</strong>를 분리시킬 수 없다. 항상 함께 실행되어야 한다. 순서도 변경할 수 없다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-부수효과-제거side-effect-free"></a>🎈 부수효과 제거(Side effect-free)<a class="hash-link" href="#-부수효과-제거side-effect-free" title="Direct link to heading">#</a></h4><ul><li>다음 예제는 가격을 2배로 증가시키는 실수를 저질렸다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void print(Cash price) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  System.out.println(&quot;Tody price is: &quot; + price);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  price.mul(2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  System.out.println(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;Buy now, tomorrow price is: &quot; + price</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이제 이 메서드를 호출하면 부수효과가 발생한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash five = new Cash(5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">print(five);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(five); // &quot;$10&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>문제를 해결하기 위해 문제가 발생한 지점을 찾기 위해서 <code>five</code> 객체를 수정한 모든 곳을 디버깅해야 한다.</li><li>반면에 <code>Cash</code> 클래스를 불변으로 만들면 어떤 누구도 객체를 수정할 수 없다. 그리고 객체의 상태가 변하지 않았다고 확신할 수 있다. 코드가 제대로 동작하지 않아도 부수효과가 발생한 위치를 찾을 필요가 없다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-null-참조-없애기"></a>🎈 NULL 참조 없애기<a class="hash-link" href="#-null-참조-없애기" title="Direct link to heading">#</a></h4><ul><li>설정되지 않은(unset) 프로퍼티에 관한 예제이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class User {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private String name = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public User(int num) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.id = num;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setName(String txt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.name = txt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 클래스의 인스턴스가 생성될 때 <code>name</code> 프로퍼티의 값으로 <code>NULL</code>이 할당된다. 이 값은 나중에 <code>setName()</code> 메서드를 호출할 때 초기화되고, 그 전까지는 값이 <code>NULL</code>인 상태를 유지한다.</li><li><code>NULL</code>은 빈 문자열과 크게 다르지 않다. <code>NULL</code>이 아닌지 체크해야하고, 문제가 없는지 확인해야 한다. 그리고 문제는 어김없이 발생한다.</li><li>더 큰 문제는 실제 값이 아닌 <code>NULL</code>을 참조하는 객체는 <strong>유지보수성</strong>이 저하될 수 밖에 없다. 언제 객체가 유효한 상태인지 언제 <strong>객체가 아닌</strong> 다른 형태로 바뀌는 지를 이해하기가 어렵기 때문이다.</li><li>모든 객체를 불변으로 만들면 객체 안에 <code>NULL</code>을 포함시키는 것이 애초에 불가능해져 작고, 견고하며,응집도 높은 객체를 생성할 수 밖에 없도록 <strong>강제되기 때문에</strong> 유지보수하기에 훨씬 더 쉬운 객체를 만든다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-스레드-안정성thread-safety"></a>🎈 스레드 안정성(Thread Safety)<a class="hash-link" href="#-스레드-안정성thread-safety" title="Direct link to heading">#</a></h4><ul><li>스레드 안정성이란 여러 스레드에서 동시에 사용될 수 잇으며 그 결과를 항상 <strong>예측가능하도록</strong> 유지할 수 있는 객체의 품질을 의미한다.</li><li>불변 객체는 실행 시점에 상태를 상태를 수정할 수 없게 금지함으로써 결과를 항상 예측가능하도록 유지할 수 있다. 어떤 스레드도 객체의 상태를 수정할 수 없기 때문에 가능하다.</li><li>명시적으로 동기화를 이용하면 가변 클래스 역시 스레드에 안전하게 만들 수는 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int cents;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void mul(int factor) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized (this) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.dollars *= factor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.cents *= factor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>정상적으로는 동작하지만 문제점이 있다. 첫째, 가변 클래스에 스레드 안전성을 추가하는 일은 생각처럼 쉽지 않다. 둘째, 동기화 로직을 추가하는 일은 성능상의 비용을 초래한다. 각 스레드는 객체를 <strong>배타적으로 잠그기 때문에</strong> 다른 모든 스레드는 객체가 해제될 때까지 기달릴 수밖에 없다.</li><li>이런 이유로 가변 객체를 피하고 불변 객체를 사용해야 한다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-더-작고-더-단순한-객체"></a>🎈 더 작고 더 단순한 객체<a class="hash-link" href="#-더-작고-더-단순한-객체" title="Direct link to heading">#</a></h4><ul><li>객체가 더 단순해질 수록 응집도는 더 높아지고, 유지보수하기는 더 쉬워진다.</li><li>대부분의 경우, 단순하다는 것은 더 적은 코드 줄수를 의미한다. 한 클래스 안에 1000줄의 코드가 들어있다면, 작성자조차도 클래스가 어떤 일을 하는지 모를 것이 분명하다. 최대 크기는 주석과 공백을 포함해 250줄정도.. (여기서 코드란 프로덕션 코드와 테스트 코드 포함)</li><li>불변 객체는 아주 크게 만드는 일이 불가능하고, 일반적으로 불변 객체는 가변 객체보다 더 작다. (불변 객체가 작은 이유는 생성자 안에서만 상태를 초기화할 수 있다.)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-문서를-작성하는-대신-테스트를-만드세요"></a>🦄 문서를 작성하는 대신 테스트를 만드세요<a class="hash-link" href="#-문서를-작성하는-대신-테스트를-만드세요" title="Direct link to heading">#</a></h3><ul><li>문서화는 유지보수에 있어 중요한 구성요소이다.</li><li>클래스나 메서드에 관한 추가정보에 얼마나 쉽게 접근할 수 있는 지가 중요하다.</li><li>이상적인 코드는 스스로 설명하기 때문에 어떤 추가 문서도 필요하지 않는다. 따라서 코드를 문서화하는 대신 코드를 깔끔하게 만들어야 한다.</li><li>여기서 깔끔하게 만든다라는 말에는 단위 테스트도 함께 만든다는 의미가 포함되어 있다.</li><li>깔끔하고 유지보수 가능한 단위 테스트를 추가하면, 클래스를 더 깔끔하게 만들 수 있고 유지보수성을 향상시킬 수 있다. 더 훌륭한 단위 테스트를 작성할수록 더 적은 문서화가 요구된다. <strong>단위 테스트가 바로 문서화이다.</strong></li><li>훌륭하고 깔끔한 단위 테스트를 만들기 위한 최고의 조언은 메인 코드만큼 단위 테스트에도 관심을 기울여야 한다.</li><li>다음은 <code>Cash</code> 클래스의 단위 테스트이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class CashTest {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Test</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void summarizes() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertThat(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Cash(&quot;$5&quot;).plus(new Cash(&quot;$3&quot;)),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      equalTo(new Cash(&quot;$8&quot;))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Test</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void deducts() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertThat(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Cash(&quot;$7&quot;).plus(new Cash(&quot;-$11&quot;)),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      equalTo(new Cash(&quot;-$4&quot;))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Test</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void multiplies() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertThat(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Cash(&quot;$2&quot;).mul(3),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      equalTo(new Cash(&quot;$6&quot;))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-모의-객체mock-대신-페이크-객체fake를-사용하세요"></a>🦄 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요<a class="hash-link" href="#-모의-객체mock-대신-페이크-객체fake를-사용하세요" title="Direct link to heading">#</a></h3><ul><li>테스트를 최적화하기 위한 도구인 <strong>모킹</strong>이다.</li><li>다음은 자기 자신을 새로운 환율로 변환할 수 있는 <code>Cash</code> 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Exchange exchange;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int cents;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Cash(Exchange exch, int cnts) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.exchange = exch;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.cents = cnts;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Cash in(String currency) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Cash(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.exchange,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.cents * this.exchange.rate(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;USD&quot;, currency</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Cash</code>는 <code>Exchange</code>클래스에 의존하기 때문에 <code>Cash</code> 클래스를 사용하기 위해서는 <code>Exchange</code>의 인스턴스를 <code>Cash</code>의 생성자에 전달해야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// NYSE 클래스는 USD에서 EUR로 변환하기 위한 환율을 찾는 방법을 알고 있다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 패스워드로 secret을 사용하고 있다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash dollar = new Cash(new NYSE(&quot;secret&quot;), 100);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash euro = dollar.in(&quot;EUR&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>우리는 <code>NYSE</code>가 개입하지 않고 <code>Cash</code> 클래스를 테스트할 수 있는 방법이 필요하다.</li><li>전통적인 접근방식은 모킹으로 <code>NYSE</code>를 사용하는 대신 <code>Exchange</code> 인터페이스에 대한 모의 객체를 생성한 후 <code>Cash</code> 생성자의 인자로 사용한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Exchange exchange = Mockito.mock(Exchange.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Mockito.doReturn(1.15)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .when(exchange)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .rate(&quot;USD&quot;, &quot;EUR&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash dollar = new Cash(exchange, 500);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash euro = dollar.in(&quot;EUR&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;5.75&quot;.equals(euro.toString());</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>모킹 대신 페이크 객체를 사용하는 것이 좋다.</li><li>다음은 사용자에게 전달될 <code>Exchange</code> 인터페이스의 최종 코드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String origin, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final class Fake implements Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    float rate(String origin, String target) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return 1.2345;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>중첩된 페이크 클래스는 인터페이스의 일부이며 인터페이스와 함께 제공된다.</li><li>아래는 모킹 대신 페이크 클래스를 사용한 단위 테스트이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Exchange exchange = new Exchange.Fake();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash dollar = new Cash(exchange, 500);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cash euro = dollar.in(&quot;EUR&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;6.17&quot;.equals(euro.toString());</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>페이크 클래스를 만족하도록 테스트를 작성하지 말고, 페이크 클래스가 테스트를 올바르게 지원하도록 만들어야 한다. 페이크 클래스를 사용하면 테스트를 더 짧게 만들 수 있기 때문에 유지보수성이 눈에 띄게 향상된다.</li><li>반면에 모킹의 경우, 테스트가 장황해지고, 이해하거나 리팩토링하기 어려워진다. 또한, 모킹은 가정을 사실로 전환시키기 때문에 단위 테스트를 유지보수하기 어렵게 만든다.</li><li>클래스의 행동이 변경되면 단위 테스트가 실패하기 때문에, 단위 테스트은 코드 리팩토링에 큰 도움이 된다. 하지만 동시에 <strong>행동이 변경되지 않을 경우에는 실패해서는 안된다.</strong></li><li>하지만 앞에서 살펴본 단위 테스트는 아무런 이유 없이도 실패할 수 있다. <code>Exchange</code> 인터페이스를 다음과 같이 수정한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String origin, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음과 같이 변경한 후 <code>origin</code> 통화가 <code>USD</code>일 경우 하나의 인자를 받는 새로운 <code>rate</code> 메서드를 사용하도록 <code>Cash</code> 클래스를 수정한다고 가정하면, 단위 테스트가 실패할 것이다. 아무 것도 실패하지 않았지만, 테스트는 실패했다는 잘못된 신호를 보낸다.</li><li>단위 테스트는 너무 쉽게 깨지고 불안정하고 대부분의 실패는 모킹 때문에 일어난다.</li><li>다음은 동일한 상황에서 <code>Exchange</code> 인터페이스를 변경하기 위해서는 자연수럽게 <code>Exchange.Fake</code> 클래스의 구현도 함께 변경해야 한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String origin, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final class Fake implements Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    float rate(String target) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return this.rate(&quot;USD&quot;, target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    float rate(String origin, String target) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return 1.2345;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위와 같이 페이크 객체를 사용하면 단위 테스트가 깨지지 않는다.</li><li>모킹은 <strong>나쁜 프랙티스</strong>이다. 모킹은 클래스 구현과 관련된 내부 세부사항을 테스트와 결합시킨다.</li><li>반대로 페이크 클래스를 사용하면 테스트를 충분히 유지보수 가능하게 만들 수 있다. <code>Cash</code> 클래스와 <code>Exchange</code> 클래스 사이의 의사소통 방식에 대해서는 신경 쓸 필요가 없기 때문이다.</li><li>페이크 클래스의 중요한 장점 한 가지는 페이크 클래스는 인터페이스의 설계에 관해 더 깊이 고민하도록 해준다. 인터터이스를 설계하면서 페이크 클래스를 만들다보면 플연적으로 인터페이스의 작성자뿐만 아니라 사요자의 관점에서도 고민한다. 인터페이스를 다른 관점에서 바라보고 테스트 리소스를 사용해서 사용자와 동일한 기능을 구현한다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-인터페이스를-짧게-유지하고-스마트smart를-사용하세요"></a>🦄 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요<a class="hash-link" href="#-인터페이스를-짧게-유지하고-스마트smart를-사용하세요" title="Direct link to heading">#</a></h3><ul><li>두 개의 인터페이스가 각각 5개의 메서드를 선언하고 있다면, 두 인터페이스를 모두 구현하는 클래스는 10개의 <code>public</code> 메서드를 가지기 때문에 이 클래스를 우아하다고 말하기는 어렵다.</li><li>앞 섹션에서 설명한 <code>Exchange</code> 인터페이스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String source, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 인터페이스는 너무 많은 것을 요구하기 때문에 설계 관점에서는 형편 없는 인터페이스이다.</li><li>이런 종류의 계약은 단일 책임 원칙을 위반하는 클래스를 만들도록 부추긴다. 다시 말해서 응집도가 낮은 클래스를 만들게 한다.</li><li>두 <code>rate</code> 메서드는 독립적인 함수이다. 하나의 인자를 받는 <code>rate</code> 메서드는 이 인터페이스에 포함되어서는 안된다.</li><li>이를 해결하기위해서 인터페이스 안에 <strong>스마트</strong> 클래스를 추가해서 해결할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String source, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final class Smart {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Exchange origin;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float toUsd(String source) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return this.origin.rate(source, &quot;USD&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 스마트 클래스는 <code>Exchange</code> 인터페이스가 어떻게 구현되고 환율이 어떻게 계산되는 지는 모르지만, 인터페이스 위에 특별한 기능을 적용한다. 이 기능은 <code>Exchange</code>의 서로 다른 구현 사이에 공유될 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">float rate = new Exchange.Smart(new NYSE()).toUsd(&quot;EUR&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>모든 <code>Exchange</code> 구현체에 동시에 더 많은 기능을 추가해야 한다고 가정한다. <code>EUR</code>라는 문자열 리터럴을 반복적으로 사용하고 싶지는 않다. 때문에 <code>eurToUsd()</code> 메서드를 사용할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String source, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final class Smart {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Exchange origin;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float toUsd(String source) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return this.origin.rate(source, &quot;USD&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float eurToUsd() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return this.toUsd(&quot;EUR&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이제 단 한번의 메서드 호출만으로 <code>EUR</code>에서 <code>USD</code>로의 환율을 얻을 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">float rate = new Exchange.Smart(new NYSE()).eurToUsd();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>스마트 클래스의 크기는 점점 더 커지겠지만, <code>Exchange</code> 인터페이스는 작고, 높은 응집도를 유지할 수 있다.</li><li>인터페이스를 짧게 만들고 스마트 클래스를 인터페이스와 함께 배포함으로써 공통 기능을 추출하고 코드 중복을 피할 수 있다.</li><li>이러한 접근방법은 데코레이터와 매우 유사하다. 테코레이터와 스마트 클래스와 다른 점은 스마트 클래스가 객체에 새로운 메서드를 추가하는데 비해 테코레이터는 이미 존재하는 메서드를 좀 더 강력하게 만든다는 점이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  float rate(String origin, String target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  final class Fast implements Exchange {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Exchange origin;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float rate(String source, String target) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      final float rate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (source.equals(target)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        rate = 1.0f;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        rate = this.origin.rate(source, target);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return rate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public float toUsd(String source) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return this.origin.rate(source, &quot;USD&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>중첩 클래스인 <code>Exchange.Fast</code>는 데코레이터인 동시에 스마트 클래스이다. 첫째, <code>Exchange.Fast</code>는 <code>rate()</code> 메서드를 오버라이드해서 더 강력하게 만든다. 둘째, <code>Exchange.Fast</code>는 새로운 메서드인 <code>toUsd()</code>를 추가해서 <code>USD</code>로 쉽게 환율을 변혼할 수 있도록 해준다.</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/saseungmin/reading_books_record_repository/tree/master/docs/object-oriented/elegant-object/chapter-2.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-1"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 🌈 Chapter 1: Birth</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">🌈 Chapter 3: Employment »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-가능하다면-적게-캡슐화하세요" class="table-of-contents__link">🦄 가능하다면 적게 캡슐화하세요</a></li><li><a href="#-최소한-뭔가는-캡슐화하세요" class="table-of-contents__link">🦄 최소한 뭔가는 캡슐화하세요</a></li><li><a href="#-항상-인터페이스를-사용하세요" class="table-of-contents__link">🦄 항상 인터페이스를 사용하세요.</a></li><li><a href="#-메서드-이름을-신중하게-선택하세요" class="table-of-contents__link">🦄 메서드 이름을 신중하게 선택하세요</a></li><li><a href="#-퍼블릭-상수public-constant를-사용하지-마세요" class="table-of-contents__link">🦄 퍼블릭 상수(Public Constant)를 사용하지 마세요</a></li><li><a href="#-불변-객체로-만드세요" class="table-of-contents__link">🦄 불변 객체로 만드세요</a></li><li><a href="#-문서를-작성하는-대신-테스트를-만드세요" class="table-of-contents__link">🦄 문서를 작성하는 대신 테스트를 만드세요</a></li><li><a href="#-모의-객체mock-대신-페이크-객체fake를-사용하세요" class="table-of-contents__link">🦄 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요</a></li><li><a href="#-인터페이스를-짧게-유지하고-스마트smart를-사용하세요" class="table-of-contents__link">🦄 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/functional/table-of-contents">함수형</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/test/table-of-contents">테스트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/etc/table-of-contents">기타</a></li></ul></div><div class="col footer__col"><div class="footer__title">Link</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/saseungmin" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://haranglog.tistory.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="mailto:dbd02169@naver.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>E-mail<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.facebook.com/saseungmin95" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/saseungmin/reading_books_record_repository/tree/master/summarize_books_in_markdown" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github Markdown에서 보기<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub Repository<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Summary of Books, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/reading_books_record_repository/assets/js/runtime~main.3025a413.js"></script>
<script src="/reading_books_record_repository/assets/js/main.4307086f.js"></script>
</body>
</html>