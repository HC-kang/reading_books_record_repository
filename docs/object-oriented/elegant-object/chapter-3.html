<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VJSDQ25SYT"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-VJSDQ25SYT",{})</script><title data-react-helmet="true">🌈 Chapter 3: Employment | Summary of Books</title><meta data-react-helmet="true" property="og:url" content="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🌈 Chapter 3: Employment | Summary of Books"><meta data-react-helmet="true" name="description" content="🦄 5개 이하의 public 메서드만 노출하세요"><meta data-react-helmet="true" property="og:description" content="🦄 5개 이하의 public 메서드만 노출하세요"><link data-react-helmet="true" rel="shortcut icon" href="/reading_books_record_repository/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3"><link data-react-helmet="true" rel="alternate" href="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://saseungmin.github.io/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3" hreflang="x-default"><link rel="stylesheet" href="/reading_books_record_repository/assets/css/styles.cefedd52.css">
<link rel="preload" href="/reading_books_record_repository/assets/js/runtime~main.d93cb603.js" as="script">
<link rel="preload" href="/reading_books_record_repository/assets/js/main.38cf8773.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/reading_books_record_repository/"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Summary of Books</b></a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/reading_books_record_repository/"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Summary of Books</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></li><li class="menu__list-item"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/intro">책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">코어 자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-1">🌈 Chapter 1: 데이터 타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-2">🌈 Chapter 2: 실행 컨텍스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-3">🌈 Chapter 3: this</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-4">🌈 Chapter 4: 콜백 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-5">🌈 Chapter 5: 클로저</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-6">🌈 Chapter 6: 프로토타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-7">🌈 Chapter 7: 클래스</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">자바스크립트 코딩의 기술</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-1">1. 변수 할당으로 의도를 하라</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-2">2. 배열로 데이터 컬렉션을 관리하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-3">3. 특수한 컬렉션을 이용해 코드 명료성을 극대화하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-4">4. 조건문을 깔끔하게 작성하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-5">5. 반복문을 단순하게 만들어라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-6">6. 매개변수와 return 문을 정리하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-7">7. 유연한 함수를 만들어라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-8">8. 클래스로 인터페이스를 간결하게 유지하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-9">9. 외부 데이터에 접근하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-10">10. 컴포넌트 아키텍처를 이용해 관련 파일을 모아라.</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">애자일</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">클린 애자일</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-1">👉 Chapter 1: 애자일 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-2">👉 Chapter 2: 왜 애자일인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-3">👉 Chapter 3: 비즈니스 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-4">👉 Chapter 4: 팀 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-5">👉 Chapter 5: 기술 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-6">👉 Chapter 6: 애자일해지기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-7">👉 Chapter 7: 장인 정신</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">린 UX</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-1">🌈 왜 린 UX인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-2">🌈 기본 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-3">🌈 비전 정의와 실행 계획, 성과</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-4">🌈 협업기반 디자인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-5">🌈 MVP와 실험</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-6">🌈 조사와 피드백</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-7">🌈 애자일과 린 UX의 통합</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-8">🌈 조직 변화 만들기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">The Nature of Software Development</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-1">1. 가치 찾기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-2">2. 가치, 우리가 원하는 것</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-3">3. 피처 단위 개발을 위한 가이드라인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-4">4. 피처 단위로 조직 구성하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-5">5. 피처 단위로 계획하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-6">6. 피처 단위로 개발하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-7">7. 피처와 기반을 동시에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-8">8. 무결점과 견고한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-9">9. 요약</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-10">10. 가치에 대해서</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-11">11. 가치를 정하는 기준</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-12">12. 물론 힘들 일입니다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-13">13. 그리 단순하지 않습니다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-14">14. 성장하는 개발팀 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-15">15. 초기 계획을 위한 &#x27;파이브 카드&#x27;</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-16">16. 경영진을 위한 소프트웨어 개발의 본질</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-17">17. 더 강한 채찍질</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-18">18. 속도를 내기 위한, 특별한 빌드 기술</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-19">19. 리팩토링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-20">20. 애자일 방법들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-21">21. 애자일 확장</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">함께 자라기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-1">🌈 Chapter 1: 자라기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-2">🌈 Chapter 2: 함께</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-3">🌈 Chapter 3: 애자일</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">객체지향</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-1">🌈 Chapter 1: 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-2">🌈 Chapter 2: 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-3">🌈 Chapter 3: 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-4">🌈 Chapter 4: 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-5">🌈 Chapter 5: 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-6">🌈 Chapter 6: 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-7">🌈 Chapter 7: 함께 모으기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-1">🌈 Chapter 1: 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-2">🌈 Chapter 2: 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-3">🌈 Chapter 3: 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-4">🌈 Chapter 4: 설계 품질과 트레이드오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-5">🌈 Chapter 5: 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-6">🌈 Chapter 6: 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-7">🌈 Chapter 7: 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-8">🌈 Chapter 8: 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-9">🌈 Chapter 9: 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-10">🌈 Chapter 10: 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-11">🌈 Chapter 11: 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-12">🌈 Chapter 12: 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-13">🌈 Chapter 13: 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-14">🌈 Chapter 14: 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-15">🌈 Chapter 15: 디자인 패턴과 프레임워크</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">루비로 배우는 객체지향 디자인</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-1">✌️ Chapter 1: 객체지향 디자인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-2">✌️ Chapter 2: 단일 책임 원칙을 따르는 클래스 디자인하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-3">✌️ Chapter 3: 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-4">✌️ Chapter 4: 유연한 인터페이스 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-5">✌️ Chapter 5: 오리 타입으로 비용 줄이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-6">✌️ Chapter 6: 상속을 이용해 새로운 행동 얻기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-7">✌️ Chapter 7: 모듈을 통한 역할 공유</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-8">✌️ Chapter 8: 조합을 이용해 객체 통합하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-9">✌️ Chapter 9: 비용-효율적인 테스트 디자인하기</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">엘레강트 오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-1">🌈 Chapter 1: Birth</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2">🌈 Chapter 2: Education</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3">🌈 Chapter 3: Employment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-4">🌈 Chapter 4: Retirement</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">테스트 주도 개발로 배우는 객체 지향 설계와 실천</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-1">1. 테스트 주도 개발의 핵심은 무엇인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-2">2. 객체를 활용한 테스트 주도 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-3">3. 도구 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-4">4. 테스트 주도 주기 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-5">5. 테스트 주도 개발 주기의 유지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-6">6. 객체 지향 스타일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-7">7. 객체 지향 설계의 달성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-8">8. 서드 파티 코드를 기반으로 한 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-9">9. 경매 스나이퍼 개발 의뢰</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-10">10. 동작하는 골격</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-11">11. 첫 테스트 통과하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-12">12. 입찰 준비</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-13">13. 스나이퍼가 입찰하다</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-14">14. 스나이퍼가 경매에서 낙찰하다</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-15">15. 실제 사용자 인터페이스를 향해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-16">16. 여러 품목에 대한 스나이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-17">17. Main 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-18">18. 세부 사항 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-19">19. 실패 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-20">20. 테스트에 귀 기울이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-21">21. 테스트 가독성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-22">22. 복잡한 테스트 데이터 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-23">23. 테스트 진단</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-24">24. 테스트 유연성</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">타입스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Do it! 타입스크립트 프로그래밍</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-1">1. 타입스크립트와 개발 환경 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-2">2. 타입스크립트 프로젝트 생성과 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-3">3. 객체와 타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-4">4. 함수와 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-5">5. 배열과 튜플</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-6">6. 반복기 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-7">7. Promise와 async/await 구문</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-8">8. 함수 조합의 원리와 응용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-9">9. 람다 라이브러리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-10">10. 제네릭 타입 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-11">11. 모나드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-12">12. 타입스크립트 함수형 프로그래밍 실습</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">클린코드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">클린 코드: 애자일 소프트웨어 장인 정신</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-1">🍭 Chapter 1: 깨끗한 코드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-2">🍭 Chapter 2: 의미있는 이름</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">🌈 Chapter 3: Employment</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-5개-이하의-public-메서드만-노출하세요"></a>🦄 5개 이하의 public 메서드만 노출하세요<a class="hash-link" href="#-5개-이하의-public-메서드만-노출하세요" title="Direct link to heading">#</a></h3><ul><li>클래스의 크기를 정한느 기준으로 <code>public</code> 메서드의 개수를 사용하길 권한다. <code>public</code> 메서드가 많을 수록 클래스도 커진다. 클래스가 커질수록 유지보수성은 저하된다. 클래스 안에 포함된 <code>public</code> 5개보다 적다면 만족스러운 수준이다.</li><li>여기서 말하는 <code>public</code> 메서드에는 <code>protected</code> 메서드도 포함된다.</li><li>클래스를 작게 만들면 우아함, 유지보수성, 응집도, 테스트 용이성이 향상된다.</li><li>클래스가 작을 때 클래스의 모든 메서드가 모든 프로퍼티와 상호작용할 가능성이 더 높아진다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-정적-메서드를-사용하지-마세요"></a>🦄 정적 메서드를 사용하지 마세요<a class="hash-link" href="#-정적-메서드를-사용하지-마세요" title="Direct link to heading">#</a></h3><ul><li>다음 예는 HTTP 요청을 전송해서 웹 페이지를 로드하는 기능을 구현한 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class WebPage {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static String read(String uri) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // HTTP 요청을 만들고 UTF-8 문자열로 변환한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음과 같이 <code>WebPage</code> 클래스를 사용할 수 있다. <code>read</code>는 정적 메서드의 일종이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">String html = WebPage.read(&#x27;http://www.example.com&#x27;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>더 나은 방식은 정적 메서드 대신 객체를 사용하는 것이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class WebPage {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final String uri;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public String content() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // HTTP 요청을 만들고 UTF-8 문자열로 변환한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음과 같이 사용할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">String html = new WebPage(&#x27;http://www.example.com&#x27;).content();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>정적 메서드는 객체 패러다임의 남용이다. 정적 메서드의 사용을 중단해야 한다.</li><li>정적 메서드는 소프트웨어를 <strong>유지보수하기 어렵게 만든다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-객체-대-컴퓨터사고"></a>🎈 객체 대 컴퓨터사고<a class="hash-link" href="#-객체-대-컴퓨터사고" title="Direct link to heading">#</a></h4><ul><li>컴퓨터는 우리가 명령어를 제공해줄 것이라고 기대하고, 제공된 명령어를 하나씩 순차적으로 실행한다. 흐름은 항상 순차적이며 스크립트의 위에서 아래로 흐른다. 문장은 위에서 아래로 흐르고 세미콜론을 기준으로 분리된다. 이런 접근방법은 규모가 더 커지면 순차적인 사고방식은 한계에 직면한다.</li><li>함수형 프로그래밍은 CPU의 계산 방식이나 함수 내부의 정확한 작동 방식을 알 수 없다. 새로운 무엇이 필요하다면 그 <strong>무엇을 정의</strong>한다.</li><li>함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그래밍과 차별화되는 점이 바로 <code>is a</code>이다.</li><li>OOP의 관점에서 최댓값을 계산하는 코드는 다음과 같다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Max implements Number {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Number a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Number b;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Max(Number left, Number right) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.a = left;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.b = right;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Number x = new Max(5, 9);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 코드는 최댓값을 계산하지 않고 단지 x가 5와 9의 최댓값이라는(<code>is a</code>) 사실을 정의할 뿐이다. 어떻게 구현하고 있는 지는 관심이 없다. 단순히 객체를 생성할 뿐이다.</li><li>정적 메서드를 이용해서 최댓값을 구하는 Java 코드이다. 잘못된 방식이며, 올바른 객체지향 설계에서는 정적 메서드를 사요애헛는 안된다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int x = Math.max(5, 9);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-선언형-스타일-대-명령형-스타일"></a>🎈 선언형 스타일 대 명령형 스타일<a class="hash-link" href="#-선언형-스타일-대-명령형-스타일" title="Direct link to heading">#</a></h4><ul><li>명령형 프로그래밍에서는 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술한다.</li><li>선언형 프로그래밍에서는 제어 흐름을 서술하지 않고 계산 로직을 표현한다.</li><li>즉, 명령형은 컴퓨터처럼 연산을 차례대로 실행, 선언형은 엔티티와 엔티티 사이의 관계로 구성돠는 자연스러운 사고 패러다임에 더 가깝다.</li><li>명령형과 선언형의 차이점은 다른 클래스, 객체, 메서드가 이 기능을 <strong>사용하는</strong> 방법에 있다.</li><li>다음은 명령형 스타일이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">// 이 정수가 간격 안에 포함되는지 여부 확인</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int between(int l, int r, int x) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Math.min(Math.max(l, x), r);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int y = Math.between(5, 9, 13); // 9를 반환</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>between</code> 메서드는 호출되는 즉시 결과를 반환한다.</li><li>메서드를 호출한 시점에 CPU가 즉시 결과를 계산한다. 이것이 바로 명령형 스타일이다.</li><li>다음은 선언형 스타일이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Between implements Number {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Number num;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Between(Number left, Number right, Number x) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.num = new Min(new Max(left, x), right);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int intValue() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.num.intValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Number y = new Between(5, 9, 13); // 아직..</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>아직까지는 CPU에게 숫자를 계산하라고 말하지 않았기 때문에, 이 방식은 선언형 스타일이다. <code>Between</code>이 <strong>무엇인지만</strong> 정의하고, 변수 <code>y</code>의 사용자가 <code>intValue()</code>의 값을 계산하는 시점에 결정한다. 이처럼 선언형 프로그래밍을 정의할 때 제어를 서술하지 않고 로직만 표현했다.</li><li>선언형 방식은 더 빠르다. 이유는 선언형 방식에서는 <strong>직접 성능 최적화를 제어할 수 있기 때문에</strong> 더 빠르다는 사실이다. 오직 하나의 정적 메서드만 호출하는 경우라면, 정적 메서드 호출하는 항식이 객체를 생성한 후 메서드를 호출하는 방식보다 빠르지만, 다수의 정적 메서드를 호출해야 하는 경우 다르다.</li><li>다음은 정적 메서드를 사용하는 예제이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void doIt() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int x = Math.between(5, 9, 13);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (/* x가 필요한가? */) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(x);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>x</code>의 값이 필요한지 여부와 무관하게 무조건 <code>x</code>의 값을 계산한다. CPU는 어떤 경우에도 <code>x</code>의 값이 9라는 사실을 알게 된다.</li><li>다음은 선언형 방식이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void doIt() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Integer x = new Between(5, 9, 13);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (/* x가 필요한가? */) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(x);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>두 번째 코드에서는 CPU에게 모든 것을 계산하라고 말하지 않는다. 대신 CPU에게 결과가 실제로 필요한 <strong>시점과 위치</strong>를 결졍하도록 위임하고, CPU는 요청이 있을 경우에만 계산을 실행한다. 때문에 실행 관점에서 선언형 방식이 더 <strong>최적화</strong>되기 때문에 더 빠르다. 최적화 관점에서 직접 통제할 수 있는 코드가 많을수록 유지보수하기도 더 쉬워진다.</li><li>선언형 방식이 더 좋은 두 번째 이유는 <strong>다형성</strong> 때문이다.</li><li><code>Between</code> 클래스에서 두 수를 비교하기 위해 <code>Min</code>과 <code>Max</code> 클래스를 사용하는 대신 <code>if-then-else</code> 구문을 사용하도록 변경하고 싶다. 다음은 선언형 방식을 따르는 코드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Between implements Number {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Number num;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Between(int left, int right, int x) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this(new Min(new Max(left, x), right));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Between(Number number) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.num = number;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 클래스를 다른 알고리즘과 함께 조합해서 사용할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Integer x = new Between(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  new IntegerWithMyOwnAlgorithm(5, 9, 13);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Between</code>과 <code>Max</code>, <code>Min</code>은 모두 <strong>클래스이기 때문에</strong> <code>Max</code>와 <code>Min</code>으로부터 <code>Between</code>을 아주 쉽게 분리할 수 있다.</li><li>생성자의 인자로 객체를 전달할 수는 있지만, 정적 메서드를 전달하는 것은 불가능하다.</li><li><strong>객체를 다른 객체로부터 완전히 분리하기 위해선는 메서드나 주 <code>ctor</code> 어디에서도 <code>new</code> 언산자를 사용하지 말아야 한다.</strong></li><li>선언형 프로그래밍을 이용하면 객체 사이의 결합도를 낮출 수 있을 뿐만 아니라, 이 작업을 우아하게 처리할 수도 있다.</li><li>선언형이 더 좋은 세 번째 이유는 <strong>표현력</strong>때문이다. 명령옇 방식에서 결과를 예상하기 위해서는 먼저 머릿속에서 코드를 실행해야 하기 때문에 명령형 방식이 선언형 방식보다 덜 직관적이다. 다음은 명령형 방식이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Collection&lt;Integer&gt; evens = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int number : numbers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if(number % 2 == 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    evens.add(number);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 코드가 하는 일을 이해하기 위해서는 코드의 실행경로를 추적해야 한다. 마음 속으로 시각화해야 한다.</li><li>다음은 선언형 스타일로 작성한 예이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Collection&lt;Integer&gt; evens = new Filtered(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  numbers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  new Predicate&lt;Integer&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean suitable(Integer number) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return number % 2 == 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// Groovy를 사용한 방법</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Collection&lt;Integer&gt; evens = new Filtered(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  numbers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  { Integer number -&gt; number % 2 == 0 }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 선언형 스타일의 코드는 <code>Filtered</code> 클래스가 이 컬렉션을 어떻게 생성하는지 모른다. 그저 컬렉션이 필터링되었나는 사실 뿐이다. <strong>코드에는 구현과 관련된 세부 사항은 감춰저 있고, 오직 행동만 표현되어 있다.</strong></li><li><strong>알고리즘</strong>과 <strong>실행</strong> 대신 <strong>객체</strong>와 <strong>행동</strong>의 관점에서 사고하기 시작하면 무엇이 올바른지 느껴질 것이다.</li><li>선언형이 더 좋은 네 번째 이유는 <strong>응집도</strong> 때문이다.</li><li>위 코드에서 <code>evens = new Filtered</code>라는 문장을 통해 <code>evens</code>를 한 줄에 선언했다. 이 경우 컬렉션의 계산을 책임지는 모든 코드들은 한 곳에 뭉쳐 있기 때문에 실수로라도 분리할 수 없다.</li><li>선언형 프로그래밍 스타일은 시간적인 결합 문제를 제거할 수 있으며, 따라서 유지보스성을 개선할 수 있다.</li><li><strong>객체와 정적 메서드를 혼용해서는 안된다.</strong> <strong>절대로 명령형 스타일을 사용해서는 안된다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-유틸리티-클래스"></a>🎈 유틸리티 클래스<a class="hash-link" href="#-유틸리티-클래스" title="Direct link to heading">#</a></h4><ul><li>유틸리티 클래스란 실제로는 클래스가 아니라 편의를 위해 다른 메서드들이 사용하는 정적 메서드들을 모아 놓은 정적 메서드들의 컬렉션(헬퍼)라도고 부른다. (<code>java.lang.Math</code>)</li><li>이런 유틸리티 클래스를 클래스라고 부르기 어려운 이유는 인스턴스를 생성하지 않기 때문이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Math {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Math() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 의도적으로 공백으로 남김</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static int max(int a, int b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (a &lt; b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return b;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>유틸리티 클래스를 구현할 때는 클래스의 인스턴스가 생성되는 것을 방지하기 위해 위와 같이 <code>private ctor</code>을 추가하는 것이 좋다. <code>ctor</code>의 가시성이 <code>private</code>이기 때문에 클래스에서 선언된 메서드를 제외한 어느 누구도 클래스의 인스턴스를 생성할 수 없다.</li><li>유틸리티 클래스는 나쁜 요소들을 모아 놓은 집합체이다. <strong>유틸리티 클래스는 안티 패턴이다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-싱글톤-패턴"></a>🎈 싱글톤 패턴<a class="hash-link" href="#-싱글톤-패턴" title="Direct link to heading">#</a></h4><ul><li>싱글톤 패턴은 정적 메서드 대신 사용할 수 있는 매우 유명한 개념이다.</li><li><code>Math</code> 클래스는 싱글톤의 대표적인 예이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Math {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static Math INSTANCE = new Math();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Math() {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static Math getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Math.INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int max(int a, int b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (a &lt; b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return b;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Math</code> 클래스의 인스턴스는 오직 하나만 존재할 수 있고, 이 유일한 인스턴스의 이름은 <code>INSTANCE</code>이다. 누구라도 <code>getInstance</code>을 호출해서 이 인스턴스에 접근할 수 있다.</li><li>싱글톤은 유명한 디자인 패턴이지만, <strong>안티 패턴</strong>이다.</li><li>다음은 위의 싱글톤 클래스와 정확하게 동일한 일을 수행하는 유틸리티 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Math {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Math() {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static int max(int a, int b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (a &lt; b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return b;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음은 두 가지 <code>max()</code> 메서드의 사용 방법이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Math.max(5, 9); // 유틸리티 클래스</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Math.getInstance().max(5, 9); // 싱글톤</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>싱글톤은 상태를 캡슐화할 수 있다는 차이점이 있다. 다음은 그 예이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class User {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static User INSTANCE = new User();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private String name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private User() {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static User getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return User.INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public String getName() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public String setName(String txt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.name = txt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>User</code>는 싱글톤이며, 싱글톤의 목적은 상태를 유지하는 것이 아니다.</li><li>다음은 <code>User</code> 유틸리티 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class User {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static String name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private User() {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static String getName() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return User.name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static String setName(String txt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    User.name = txt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>둘의 차이점은 <strong>싱글톤은 분리가 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다는 것이다.</strong> 다시 말해서 싱글톤의 장점은 <code>getInstance()</code>와 함께 <code>setInstance()</code>를 추가할 수 있다는 점이다.</li><li>다음 코드는 싱글톤 클래스 <code>Math</code>를 사용하는 코드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Math.getInstance().max(5, 9);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 코드는 <code>Math</code> 클래스에 결합되어 있다. 다시 말해서, <code>Math</code> 클래스는 이 코드가 의지하고 있는 <strong>의존성</strong>이다. 만약에 단위 테스트를 싱행하는 동안에는 <code>Math.max()</code> 메서드가 실행되지 않도록 하고 싶을 때는 다음과 같이 할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Math math = new FakeMath();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Math.setInstance(math);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>싱글톤 패턴을 사용하면 내부에 캡슐화된 정적 객체를 교체해서 전체 개념을 테스트할 수 있다. 따라서 캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 유틸리티 클래스보다는 더 좋다는 것이다.</li><li>하지만, 싱글톤은 <strong>전역 변수</strong> 그 이상도 그 이하도 아니다. 하지만 OOP에서는 전역 변수를 허용하지 않는다.</li><li>싱글톤은 어떤 사람이 Java에서 전역 변수를 사용할 수 있는 방법을 발견했고, 그 결과로 만들어진 것이 바로 싱글톤이다. 싱글톤은 객체지향 패러다임의 잘못 사용한 예이다.</li><li><strong>절대로 싱글톤을 사용하면 안된다.</strong></li><li>싱글톤에 대한 대안은 캡슐화를 사용하면 된다. 클래스가 작업을 수행하는데 필요한 모든 요소들이 생성자에 제공되고 내부에 캡슐화돼야 한다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-함수형-프로그래밍"></a>🎈 함수형 프로그래밍<a class="hash-link" href="#-함수형-프로그래밍" title="Direct link to heading">#</a></h4><ul><li>FP보다 OOP의 표현력이 더 뛰어나고 강력하다. FP에서는 오직 함수만 사용할 수 있지만 OOP에서는 객체와 메서드를 조합할 수 있다.</li><li>이상적인 OOP 언어에는 클래스와 함께 함수가 포함되어야 한다. 작은 프로시저로 동작하는 Java의 메서드가 아니라, 하나의 출구만 포함하는 순수한 FP 패러다임에 기반하는 진정한 함수를 포함해야 한다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-조합-가능한-데코레이터"></a>🎈 조합 가능한 데코레이터<a class="hash-link" href="#-조합-가능한-데코레이터" title="Direct link to heading">#</a></h4><ul><li>조합 가능한 데코레이터는 그저 다른 객체를 감싸는 객체일 뿐이다. 이것은 디자인 패턴인 데코레이터일 뿐이지만, 이 데코레이터 객체들을 다중계층 구조로 구성하기 시작하면 다음 예제처럼 조합 가능해진다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">names = new Sorted(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  new Unique(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Capitalized(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Replaced(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        new FileNames(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          new Directory(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;/var/users/*.xml&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;([^.]+)\\.xml&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;$1&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 코드는 매우 깔끔하면서도 객체지향적이다. 또한 순순하게 선언형이다.</li><li>단지 선언만 했을 뿐인데, 이 객체가 무엇인지를 설명할 수 있다.</li><li>이런 객체들을 조합가능한 데코레이터라고 부른다. <code>Directory</code>, <code>FileNames</code>, <code>Replaced</code>, <code>Capitalized</code>, <code>Unique</code>, <code>Sorted</code> 클래스 각각은 하나의 데코레이터이다.</li><li>객체들의 전체적인 행동은 내부에 캡슐화하고 있는 객체들에 의해 유도된다. 각 데코레이터는 내부에 캡슐화하고 있는 객체에 별도의 행동을 추가한다. 데코레이터의 상태는 내부에 캡슐화하고 있는 객체들의 상태와 동일하다.</li><li><code>if</code>, <code>for</code>. <code>switch</code>. <code>while</code>과 같은 절차적인 문장이 포함되어 있어서는 안된다.</li><li><code>if</code>는 Java 언어에서 제공하는 연산자이며, 문장을 차례대로 나열하는 절차적인 방식으로 <code>if</code>를 사용한다. 미래에는 Java를 대체할 언어가 연산자 <code>if</code> 대신 클래스 <code>If</code>를 제공하지 못할 이유는 없다. 절차적인 코드 대신 다음과 같이 할 수도 있을 것이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">float rate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (client.age() &gt; 65) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  rate = 2.5;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  rate = 3.0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 객체지향적인 방식으로 개선</span></span><span class="token-line" style="color:#393A34"><span class="token plain">float rate = new If(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  new GreaterThan(new AgeOf(client), 65),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  2.5, 3.0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 코드는 순수하게 객체지향이면서도 선언형이다. 어떤 일도 하지 않으며, 오직 <code>rate</code>가 무엇인지만 선언한다.</li><li>여기서의 요점은 절차적인 연산자가 필요하지 않다는 점이다.</li><li>긴 메서드와 복잡한 프로시저의 사용을 최대한 자제해야 하고, 작으면서 조합 가능한 클래스들을 설계하고, 더 큰 객체를 조합하기 위해 작은 클래스들을 재사용할 수 있도록 만들어야 한다.</li><li>객체지향 프로그래밍이란 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업이다.</li><li>위와 같은 내용들은 정적 메서드를 사용하면 조합이 불가능해진다. <strong>결론적으로, 소프트웨어 어디에서도 <code>static</code> 키워드를 사용해서는 안된다.</strong></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-인자의-값으로-null을-절대-허용하지-마세요"></a>🦄 인자의 값으로 NULL을 절대 허용하지 마세요<a class="hash-link" href="#-인자의-값으로-null을-절대-허용하지-마세요" title="Direct link to heading">#</a></h3><ul><li><code>NULL</code>은 정적 메서드 및 가변성과 더불어 객체지향 세계의 골치거리 중 하나다.</li><li>다음 메서드의 설계를 살펴보자.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; find(String mask) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 디렉토리를 탐색해서 &quot;*.txt&quot;와 같은 형식의</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 마스크에 일치하는 모든 파일을 찾는다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 마스크가 NULL인 경우에는 모든 파일을 반환한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>실제로 <code>NULL</code>을 전달하는 방법은 아래의 두 메서드를 하나로 합칠 수 있는 편리한 방법처럼 보인다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; findAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; find(String mask);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>하나의 메서드만 제공하면 사용자가 더 쉽고 간편하게 기억할 수 있다.</li><li><code>NULL</code>을 허용하는 <code>find()</code> 메서드를 구현하기 위해서는 다음과 같이 분기를 처리할 필요가 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; find(String mask) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (mask == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 모든 파일</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 마스크를 사용해서 파일을 찾는다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 코드에서 문제가 되는 부분은 <code>mask == null</code>이다. <code>mask</code> 객체에게 이야기하는 대신, 이 객체를 피하고 무시한다.</li><li>객치를 <strong>존중한다면</strong> 다음과 같이 행동한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; find(Mask mask) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (mask.empty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 모든 파일</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 마스크를 사용해서 파일을 찾는다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 코드를 더 개선할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; find(Mask mask) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Collection&lt;File&gt; files = new LinkedList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (File file: /* 모든 파일*/) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (mask.matches(file)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      files.add(file);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return files;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>인자의 값으로 <code>NULL</code>을 허용하면 <code>mask == null</code>과 같은 비교문을 사용할 수 밖에 없다. <code>NULL</code> 여부를 체크함으로써 객체가 맡아야 하는 상당량의 책임을 빼앗게 된다. 외부에서 자신의 데이터를 다뤄주기만을 기대하고 스스로를 책임질 수 없게 된다.</li><li>OOP에서 존재하지 않는 인자 문제는 널 객체를 이용해서 해결해야 한다. 전달할 것이 없다면, 비어있는 것처럼 행동하는 객체를 전달하면 된다. 전달한 인자가 객체인지 <code>NULL</code>인지를 확인하는 짐을 메서드 구현자에게 떠넘겨서는 안된다. 대신 항상 객체를 전달하되, 전달한 객체에게 무리한 요청을 한다면 응답을 거부하도록 객체를 구현해야 한다.</li><li>다음과 예제처럼 검색 조건을 지정하기 위해 <code>find()</code> 메서드에 전달하는 <code>Mask</code> 인터페이스가 있다고 가정한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">interface Mask {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  boolean matches(File file);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 인터페이스의 적절한 구현은 글롭 패턴(<code>*.txt</code> 형식의 패턴)을 캡슐화하고 이 패턴에 대해 파일 이름을 매칭시킬 것이다. 반면에 널 객체에는 다음과 같이 구현할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class AnyFile implements Mask {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  boolean matches(File file) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 경우는 어떤 내부 로직도 포함하지 않고, 어떤 파일을 전달하더라도 항상 <code>true</code>를 반환한다. 이제 <code>null</code>을 전달하는 대신, <code>AnyFile</code>의 인스턴스를 생성해서 <code>find()</code> 메서드에 전달하면 된다.</li><li>메서드가 인자의 값으로 <code>NULL</code>을 허용하지 않기로 했다고 가정했지만, 클라이언트가 여전히 <code>NULL</code>을 전달한다면 하나는 방어적인 방법으로 <code>NULL</code>을 체크한 후 예외를 던진다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public Iterable&lt;File&gt; find(Mask mask) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (mask == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new IllegalArgumentException(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      &quot;Mask can&#x27;t be NULL; please provide an object.&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 마스크를 사용해서 파일을 찾아 반환</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>두 번째 방법은 <code>NULL</code>을 무사하는 것이다. 여기서는 인자가 절대 <code>NULL</code>이 아니라고 가정하고 어떤 대비도 하지 않는다. 메서드를 실행하는 도중에 인자에게 접근하면 <code>NullPointerException</code>이 던져지고 메서드 호출자는 실수했다는 사실을 인지하게 될 것이다.</li><li>중요하지 않은 <code>NULL</code> 확인 로직으로 코드를 오명시켜서는 안된다. 방어적으로 대응하기보단 무시함으로써 JVM에 정의된 표준방식으로 처리하는 것이 좋다.</li><li>요약하자면 <strong>메서드 인자에 절대 <code>NULL</code>을 허용하지 마라.</strong></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-충성스러우면서-불변이거나-아니면-상수이거나"></a>🦄 충성스러우면서 불변이거나, 아니면 상수이거나<a class="hash-link" href="#-충성스러우면서-불변이거나-아니면-상수이거나" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class WepPage {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final URI uri;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  WebPage (URI path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.uri = path;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public String content() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // HTTP GET 요청 전송</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 웹 페이지의 컨텐츠를 읽은 후,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 읽혀진 컨텐츠를 UTF-8 문자열로 변환한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 예제의 <code>WebPage</code>는 불변이다. <code>content()</code> 메서드가 호출할 때마다 서로 다른 값이 반홚되더라도 이 객체는 불변이다. 여기에서 객체의 행동이나 메서드의 반환값은 중요하지 않다. 핵심은 <strong>객체가 살아있는 동안 상태가 변하지 않는다는 사실이다.</strong></li><li>일단 이 클래스들로부터 인스턴스를 생성하고나면, 생선된 객체의 모든 메서드는 항상 동일한 값을 반환한다. 때문에 100% 예측할 수 있다.</li><li>불변 객체는 예를 들어, <code>content()</code> 메서드의 결과를 예측할 수는 없더라도 <code>WebPage</code>는 불변 객체에 속한다. 우리는 이 객체가 무엇을 돌려줄지 알지 못한다. 객체의 행동을 예상할 수는 없지만, 그럼에도 이 객체는 불변이다.</li><li>결과가 변하기 때문에 상수는 아니지만, 객체가 대표하는 엔티티에 <strong>충성하기</strong> 때문에 불변 객체로 분류된다.</li><li>객체란 웹 페이지, 바이트 배열, 해시맵, 달력의 월과 같은 <strong>실제 엔티티의 대표자이다.</strong> 여기서 실제라는 말은 객체의 가시성 범위 밖에 존재하는 모든 것을 의미한다. 예를 들어 다음 코드에서 객체 <code>f</code>는 디스크에 저장되어 있는 파일을 대표한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void echo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  File f = new File(&quot;/tmp/test.txt&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  System.out.println(&quot;File size: %d&quot;,  file.length());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>여기서 <code>f</code>의 가시성 범위는 <code>echo()</code> 메서드의 경계에 대응한다.</li><li>코드에서 객체 <code>f</code>는 <code>/tmp/test.txt</code> 파일의 대표자이다. <code>echo()</code> 메서드 안에서만큼은 객체 <code>f</code>가 파일이다.</li><li>디스크에 저장된 파일을 다루기 위해 객체는 파일의 <strong>좌표</strong>를 알아야 한다. 이 좌표를 다른 말로 객체의 <strong>상태</strong>라고 부른다. 앞 예제에서 객체 <code>f</code>의 상태는 <code>/tmp/test.txt</code>이다.</li><li>모든 객체는 식별자, 상태, 행동을 포함한다. 식별자는 <code>f</code>를 다른 객체와 구별하고 상태는 <code>f</code>가 디스크 상의 파일에 대해 알고 있는 것이다. 행동은 요청을 수신했을 때 <code>f</code>가 할 수 있는 작업을 나타낸다.</li><li><strong>불변 객체와 가변 객체의 중요한 차이는 불변 객체에는 식별자가 존재하지 않으며, 절대로 상태를 변경할 수 없다는 점이다.</strong></li><li>이전 예제인 <code>WebPage</code> 객체는 동일한 <code>URI</code>를 가진 두 개의 인스턴스를 생성할 경우 두 객체는 동일한 실제 웹 페이지를 대표한다. 즉, 별도로 인스턴스를 생성했다고 하더라도, 두 객체는 동일하다.</li><li>하지만, Java를 포함한 대부분의 OOP 언어에서는 상태가 동일하더라도 서로 다른 객체라고 판단한다. 기본적으로 각 객체는 재정의 할 수 있는 자신만의 유일한 식별자를 가진다.</li><li>다음은 <code>WebPage</code> 식별자를 정의하는 예시이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class WebPage {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final URI uri;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  WebPage(URI path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.uri = path;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void equals(Object obj) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.uri.equals(WebPage.class.cast(obj).uri);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int hashCode() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.uri.hashCode();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>equals()</code>와 <code>hashCode()</code> 메서드는 모두 캡슐화된 <code>uri</code> 프로퍼티에 기반하며, <code>WebPage</code> 클래스의 객체들을 투명하게 만든다. 투명하다는 말은 객체들이 더 이상 자기 자신만의 식별자를 가지지 않는다는 뜻으로 객체들은 웹 상의 페이지를 대표하며, 객체들이 포함하는 유일한 상태는 <code>URI</code> 형태의 페이지 죄표뿐이다.</li><li>불변 객체는 좌표를 알고, 우리는 이 좌표를 상태라고 부른다. 불변 객체는 엔티티의 죄표를 절대로 변경하지 않고 어떤 경우에도 항상 동일한 엔티티를 대표한다.</li><li>다음 예제는 숫자 컬렉션을 불변 객체로 구현하는 첫번째 방법으로 상수 리스트로 구현한 방법이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class ConstantList&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final T[] array;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  ConstantList() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this(new T[0]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private ConstantList(T[] numbers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.array = numbers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  ConstantList with(T number) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    T[] nums = new T[this.array.length + 1];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.arraycopy(this.array, 0, nums, 0, this.array.length);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    nums[this.array.length] = number;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ConstantList(nums);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Iterable&lt;T&gt; iterate() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Arrays.asList(this.array);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음과 같이 사용할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">ConstantList list = new ConstantList()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .with(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .with(15)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .with(5);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>상수 리스트에서는 리스트를 수정하거나 새로운 요소를 추가할 때마다 리스트에 포함된 모든 요소의 복사본을 가지는 새로운 리스트를 생성한다.</li><li><code>this.array</code>는 <code>ConstantList</code>의 상태인 동시에 <code>ConstantList</code> 객체가 대표하는 엔티티와 동일하다.</li><li>불변 리스트는 다음과 같이 만들 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class ImmutableList&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final List&lt;T&gt; items = LinkedList&lt;T&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void add(T number) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.items.add(number);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Iterable&lt;T&gt; iterate() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Collections.unmodifiableList(this.items);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 예제의 <code>ImmutableList</code> 객체가 대표하는 실제 엔티티는 웹이 아니라 <strong>메모리</strong>에 존재한다.</li><li>요점은 개념적으로 디스크, 네트워크, 또는 기타 외부 저장소와 정확하게 동일한 방식으로 메모리를 다뤄야 한다는 것이다.</li><li>우리 입장에서 메모리 바이트는 디스크 파일과 정확하게 동일한 종류의 외부 리소스일 뿐이다. 설계 관점에서 이 둘 사이에 아무런 차이도 없으며 이 원칙을 명심하면 어떤 경우에도 불변 객체를 사용할 수 있다. 이 객체 중 일부는 상수 객체이고, 일부는 단순히 메모리의 일부를 대표하는 불변 객체이다.</li><li>상수 객체가 설계하고, 유지보수하고, 이해하기에 더 편하기 때문에 불변 객체보다는 상수 객체를 사용하는 편이 더 낫다.</li><li>결론적으로, 어떤 종류의 시스템이라도 전체적으로 불변 객체를 이용해서 설계될 수 있고 설계되어야 한다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-절대-getter와-setter를-사용하지-마세요"></a>🦄 절대 getter와 setter를 사용하지 마세요<a class="hash-link" href="#-절대-getter와-setter를-사용하지-마세요" title="Direct link to heading">#</a></h3><ul><li><code>getter</code>와 <code>setter</code>의 형태는 다음과 같다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int getDollars() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setDollars(int value) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars = value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 클래스는 가변이다. 이 클래스에 포함된 두 메서드는 이름도 잘 못 지어졌다. 이 클래스에는 생성자도 없기 때문에 섹션 2.1에서 설명한 원칙에도 위배된다.</li><li>가장 큰 문제는 바로 <code>Cash</code>가 진짜 클래스가 아니라 단순한 <strong>자료 구조</strong>라는 사실이다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-객체-대-자료구조"></a>🎈 객체 대 자료구조<a class="hash-link" href="#-객체-대-자료구조" title="Direct link to heading">#</a></h4><ul><li>다음은 C로 구현한 자료구조이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><pre tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">Cash</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> dollars</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;Cash value is %d&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> cash</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">dollars</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음은 C++에서 객체라고 불리는 요소이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;string&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">Cash</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">public</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">Cash</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> v</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">dollars</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">v</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    std</span><span class="token operator" style="color:#393A34">::</span><span class="token plain">string </span><span class="token function" style="color:#d73a49">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">private</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> dollars</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;Cash value is %s&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> cash</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">print</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이 둘의 차이점은 <code>struct</code>인 경우, 멤버인 <code>dollars</code>에 직접 접근한 후 해당 값을 정수로 취급한다. <code>struct</code>와는 아무런 의사소통도 하지 않고 직접적으로 멤버에 접근한다.</li><li>클래스는 다르게 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않는다. 게다가 자신의 멤버를 노출하지도 않는다. 심지어 <code>dollars</code>라는 멤버가 있는지조차 알 수 없다. 할 수 있는 일이라고는 <code>print()</code>하라고 요청하는 것 뿐이다. <code>print()</code>가 실제로 어떤 방식으로 동작하는 지도 알 수 없고, 캡슐화된 어떤 멤버가 이 작업에 개입하는 지도 알 수 없다. 이것이 바로 <strong>캡슐화</strong>이며, OOP가 지향하는 가장 중요한 설계 원칙 중 하나이다.</li><li>자료구조는 투명하지만, 객체는 불투명하다. 자료구조는 글래스 박스지만, 객체는 블랙 박스이다. 또한, 자료구조는 수동적이지만, 객체는 능동적이다.</li><li>자료구조를 사용하지 말아야할 이유는 늘 그렇듯이, 유지보수성과 관련이 있다.</li><li>OOP에서는 코드가 데이터를 지배하지 않고, 필요한 시점에 객체가 자신의 코드를 실행시킨다. 객체가 일급 시민이며, 생성자를 통한 객체 초기화가 곧 소프트웨어이다. 소프트웨어는 연산자나 구문이 아닌 생성자를 통해 구성된다.</li><li>객체지향적이고 선언형 스타일을 유지하기 위해서는, 데이터를 객체 안에 감추고 절대로 외부에 노출해서는 안된다. 무엇을 캡슐화하고 있고, 자료구조가 얼마나 복잡한 지는 오직 객체만이 알고 있어야 한다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-좋은-의도-나쁜-결과"></a>🎈 좋은 의도, 나쁜 결과<a class="hash-link" href="#-좋은-의도-나쁜-결과" title="Direct link to heading">#</a></h4><ul><li>근복적으로 <code>getter</code>와 <code>setter</code>는 캡슐화의 원칙을 위반하기 위해 설계되었다.</li><li>모든 현대적인 IDE는 <code>getter</code>와 <code>setter</code>를 기존의 <code>private</code> 프로퍼티에 추가하는 기능을 제공한다. Ruby는 언어 차원에서 자동으로 <code>getter</code>와 <code>setter</code>를 생성하는 기능을 내장하고 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly rb"><pre tabindex="0" class="prism-code language-rb codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  attr_reader :dollars</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  attr_writer :dollars</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>언어와 IDE 설계자들은 <code>getter</code>와 <code>setter</code>를 이용해서 <code>private</code> 프로퍼티를 감싸는 방식을 권장한다.</li><li>저자의 요점은 <code>getter</code>와 <code>setter</code>를 사용하면 OOP의 캡슐화 원칙을 손쉽게 위반할 수 있다는 점이다. 겉으로는 메서드처럼 보이지만, 실제로는 데이터에 직접 접근하고 있다는 현실이다.</li><li><strong><code>getter</code>와 <code>setter</code>의 내부 구현과 무관하게 이들은 데이터일 뿐이다. 다시 말해 행동이 아닌 데이터를 표현할 뿐이다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-접두사에-관한-모든-것"></a>🎈 접두사에 관한 모든 것<a class="hash-link" href="#-접두사에-관한-모든-것" title="Direct link to heading">#</a></h4><ul><li><code>getter/setter</code> 안티 패턴에서 유해한 부분은 두 접두사인 <code>get</code>과 <code>set</code>이라는 사실이다.</li><li>두 접두사는 이 객체가 진짜 객체가 아니고, 어떤 존중도 받을 가치가 없는 자료주고라는 사실을 명확하게 전달한다.</li><li>어떤 데이터를 반환하는 메서드를 포함하는 것은 괜찮다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int dollars() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>하지만 이 메서드의 이름을 다음과 같이 짓는 것은 적절하지 않다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int getDollars() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>여기서 <code>getDollars()</code>는 데이터 중에 <code>dollars</code>를 찾은 후 반환하라는 뜻을 지니고 있고, <code>dollars()</code>는 얼마나 많은 달러가 필요한가요? 라고 묻는 것과 같다. <code>dollars()</code>는 객체를 데이터의 저장소로 취급하지 않고, 객체를 존중한다. 데이터를 노출하지 않는다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-부-ctor-밖에서는-new를-사용하지-마세요"></a>🦄 부 ctor 밖에서는 new를 사용하지 마세요<a class="hash-link" href="#-부-ctor-밖에서는-new를-사용하지-마세요" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int euro() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Exchange().rate(&quot;USD&quot;, &quot;EUR&quot;) * this.dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 예제는 의존성에 문제가 있는 코드의 전형적인 모습이다. 하드코딩된 의존성을 가지고 있다.</li><li><code>Cash</code> 클래스는 <code>Exchange</code> 클래스에 직접 연결되어 있기 때문에, 의존성을 끊기 위해서는 <code>Cash</code> 클래스의 내부 코드를 변경할 수 밖에 없다.</li><li><code>Cash</code>를 사용한 코드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash five = new Cash(&quot;5.00&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">print(&quot;$5 equals to %d&quot;, five.euro());</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 코드는 <code>print()</code> 테스트를 실행할 때마다 매번 서버와 네트워크 통신이 발생한다. 이 경우 내부 동작은 테스트에서 제외해야 하지만 그렇지 못하다.</li><li>현재 설계에서는 <code>Cash</code>가 서버와 통신하지 않게 만들 수 없다. 둘 사이의 결합을 끊기 위해서는 <code>Cash</code>의 소스 코드를 수정해야만 한다. 이 문제의 근본 원인은 <code>new</code> 연산자이다.</li><li>다음은 수정한 후의 <code>Cash</code> 클래스이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Cash {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Exchange exchange;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Cash (int value, Exchange exch) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.dollars = value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.exchange = exch;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int euro() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.exchange.rate(&quot;USD&quot;, &quot;EUR&quot;) * this.dollars;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>다음은 <code>print</code>를 테스트하는 올바른 코드이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cash five = new Cash(5, new FakeExchange());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">print(&quot;$5 equals to %d&quot;, five.euro());</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>이렇게 수정하면 <code>Cash</code> 클래스는 더이상 <code>Exchange</code> 인스턴스를 직접 생성할 수 없고, 오직 <code>ctor</code>을 통해 제공된 <code>Exchange</code>와만 협력할 수 있다. 더 이상 <code>Exchange</code> 클래스에 의존하지 않는다.</li><li>다시 말해서, 객체가 필요한 의존성을 직접 생성하는 대신, <strong>우리가 <code>ctor</code>을 통해 의존성을 주입한다.</strong></li><li><strong>부 <code>ctor</code>을 제외한 어떤 곳에서도 <code>new</code>를 사용하지 말아야 한다.</strong> 이런 규칙을 가지면 객체들은 상호간에 충분히 분리되고 테스트 용이성과 유지보수성을 크게 향상시킬 수 있다.</li><li>다음 예는 객체가 다른 객체를 인스턴스화해야만 하는 경우의 상황이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Requests {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Socket socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Requests(Socket skt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.socket = skt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Request next() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new SimpleRequest(/* 소켓에서 데이터를 읽는다. */);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 <code>Requests</code> 클래스는 <code>next()</code> 메서드를 호출할 때마다 매번 새로운 <code>Request</code> 객체를 생성해서 반환해야 한다. <code>Request</code>는 <code>ctor</code>이 아니기 때문에 위 설계는 앞의 규칙을 위반한다.</li><li>다음과 같이 코드를 수정한다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Requests {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Socket socket;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final Mapping&lt;String, Request&gt; mapping;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Requests(Socket skt) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this(skt,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Mapping&lt;String, Request&gt;() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Request map(String data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          return new SimpleRequest(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Requests(Socket skt, Mapping&lt;String, Request&gt; mpg) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.socket = skt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.mapping = mpg;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Request next() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.mapping.map(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* 소켓에서 데이터를 읽는다. */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><code>Requests</code> 클래스는 텍스트 데이터를 <code>Request</code> 인스턴스로 변환하는 <code>Mapping</code> 인스턴스를 캡슐화한다.</li><li><code>new</code> 연산자는 오직 부 <code>ctor</code> 내부에서만 사용된다. <code>next()</code> 메서드는 더이상 <code>new</code>를 사용하지 않는다.</li><li><code>new</code>를 합법적으로 사용할 수 있는 유일한 곳은 부 <code>ctor</code> 뿐이다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-인트로스펙션과-캐스팅을-피하세요"></a>🦄 인트로스펙션과 캐스팅을 피하세요<a class="hash-link" href="#-인트로스펙션과-캐스팅을-피하세요" title="Direct link to heading">#</a></h3><ul><li>타입 인트로스펙션과 캐스팅을 사용하고 싶어도 절대 사용해서는 안된다. 기술적으로 Java의 <code>instanceof</code> 연산자와 <code>Class.cast()</code> 메서드, 다른 언어에서 동일한 기능을 수행하는 연산자들이 모두 이 범주에 포함된다.</li><li>프로그래머는 이 연산자들을 사용해서 런타임에 객체의 타입을 확인할 수 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; int size(Iterable&lt;T&gt; items) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (items instanceof Collection) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Collection.class.cast(items).size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int size = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (T item : items) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ++size;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  } </span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return size;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>타입 인트로스펙션은 <strong>리플렉션</strong>이라는 더 포괄적인 용어로 불리는 여러 가지 기법들 중 하나이다.</li><li>리플렉션을 사용하면 메서드, 명령어, 구문, 클래스, 객체, 타입 등을 변경할 수 있다. CPU가 이 요소들에 접근하기 전에 쉽고 간단하게 코드를 수정할 수 있다. 리플렉션은 매우 강력한 기법이지만 동시에 코드를 유지보수하기 어렵게 만드는 매우 너저분한 기법이다.</li><li>위 예제 코드의 접근방법은 타입에 따라 <strong>객체를 차별하기 때문에</strong> OOP의 기본 사상을 훼손시킨다. 위 코드에서 요청을 어떤 식으로 처리할 지 객체가 결정할 수 있도록 하는 대신, 객체를 배재한 상태에서 결정을 내리고, 이를 바탕으로 좋은 객체와 나쁜 객체를 차별한다.</li><li>또한, 런타임에 객체를 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서도 좋지 않다. <code>size()</code> 메서드는 <code>Iterable</code> 인터페이스 하나가 아니라, <code>Collection</code>도 포함 두 개의 인터페이스를 의존하고 있다. 유지보수성에 커다란 악영향을 끼친다.</li><li>다음은 개선한 설계이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; int size(Collection&lt;T&gt; items) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return items.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;T&gt; int size(Iterable&lt;T&gt; items) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int size = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (T item : items) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ++size;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return size;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위 기법은 <strong>메서드 오버로딩</strong>이라고 부른다.</li><li><strong>클래스 캐스팅</strong>에도 동일하게 적용된다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">return Collection.class.cast(items).size();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>위의 코드를 다음과 같이 구현할 수도 있다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">return ((Collection) items).size();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>기술적으로 두 코드는 거의 동일하게 동작한다. 최종 결과는 <code>items</code> 객체가 <code>Collection</code>이라라는 사실다.</li><li>다음 예제는 보다 완결된 예제이다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">if (items instanceof Collection) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return((Collection) items).size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>앞의 예제보다 개선된 것이 사실이지만 여전히 좋지 않다. 결합도가 숨겨져 있다.</li><li>예를들어 다음에 새로운 배관공을 파견하려고 할 때, 회사는 여러분이 프린터 수리에 추가 금액을 지불한다는 사실을 기억하고 있기 때문에 배관공인 동시에 컴퓨터 전문가인 사람을 찾으려고 시도할 것이다.</li><li>나중에 수도배관회사를 바꾸기로 결정한다면, 싱크대와 프린터를 함꼐 수리할 수 있는 사람을 다시 요청해야 한다.</li><li>다시 말해서, 방문한 객체에 대한 <strong>기대</strong>를 문서에 명시적으로 기록하지 않은 채로 외부에 노출해버린 것이다. 어떤 클라이언트는 기대하는 바를 학습한 후 더 적절한 객체에 제공하겠지만 어떤 클라이언트는 그럴 수 없을 것이다.</li><li>요약하면, <code>instanceof</code> 연산자를 사용하거나 클래스를 캐스팅하는 일은 안티패턴이기 때문에 사용해서는 안된다.</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/saseungmin/reading_books_record_repository/tree/master/docs/object-oriented/elegant-object/chapter-3.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 🌈 Chapter 2: Education</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-4"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">🌈 Chapter 4: Retirement »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-5개-이하의-public-메서드만-노출하세요" class="table-of-contents__link">🦄 5개 이하의 public 메서드만 노출하세요</a></li><li><a href="#-정적-메서드를-사용하지-마세요" class="table-of-contents__link">🦄 정적 메서드를 사용하지 마세요</a></li><li><a href="#-인자의-값으로-null을-절대-허용하지-마세요" class="table-of-contents__link">🦄 인자의 값으로 NULL을 절대 허용하지 마세요</a></li><li><a href="#-충성스러우면서-불변이거나-아니면-상수이거나" class="table-of-contents__link">🦄 충성스러우면서 불변이거나, 아니면 상수이거나</a></li><li><a href="#-절대-getter와-setter를-사용하지-마세요" class="table-of-contents__link">🦄 절대 getter와 setter를 사용하지 마세요</a></li><li><a href="#-부-ctor-밖에서는-new를-사용하지-마세요" class="table-of-contents__link">🦄 부 ctor 밖에서는 new를 사용하지 마세요</a></li><li><a href="#-인트로스펙션과-캐스팅을-피하세요" class="table-of-contents__link">🦄 인트로스펙션과 캐스팅을 피하세요</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></li></ul></div><div class="col footer__col"><div class="footer__title">Link</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/saseungmin" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://haranglog.tistory.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="mailto:dbd02169@naver.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>E-mail<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.facebook.com/saseungmin95" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/saseungmin/reading_books_record_repository/tree/master/summarize_books_in_markdown" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github Markdown에서 보기<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub Repository<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Summary of Books, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/reading_books_record_repository/assets/js/runtime~main.d93cb603.js"></script>
<script src="/reading_books_record_repository/assets/js/main.38cf8773.js"></script>
</body>
</html>