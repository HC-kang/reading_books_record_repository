<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VJSDQ25SYT"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-VJSDQ25SYT",{})</script><title data-react-helmet="true">🤔 Chapter 5: 구부러지거나 부러지거나 | Summary of Books</title><meta data-react-helmet="true" property="og:url" content="https://saseungmin.github.io/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-5"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="🤔 Chapter 5: 구부러지거나 부러지거나 | Summary of Books"><meta data-react-helmet="true" name="description" content="현대의 미친 듯이 빠른 변화 속도를 따라가려면 모든 수단을 동원하여 가능한 한 느슨하고 유연한 코드를 작성해야 한다."><meta data-react-helmet="true" property="og:description" content="현대의 미친 듯이 빠른 변화 속도를 따라가려면 모든 수단을 동원하여 가능한 한 느슨하고 유연한 코드를 작성해야 한다."><link data-react-helmet="true" rel="shortcut icon" href="/reading_books_record_repository/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://saseungmin.github.io/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-5"><link data-react-helmet="true" rel="alternate" href="https://saseungmin.github.io/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-5" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://saseungmin.github.io/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-5" hreflang="x-default"><link rel="stylesheet" href="/reading_books_record_repository/assets/css/styles.cefedd52.css">
<link rel="preload" href="/reading_books_record_repository/assets/js/runtime~main.11139799.js" as="script">
<link rel="preload" href="/reading_books_record_repository/assets/js/main.b15cc5fb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/reading_books_record_repository/"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Summary of Books</b></a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/functional/table-of-contents">함수형</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a><a class="navbar__item navbar__link" href="/reading_books_record_repository/docs/etc/table-of-contents">기타</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/reading_books_record_repository/"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/reading_books_record_repository/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Summary of Books</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/functional/table-of-contents">함수형</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></li><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/etc/table-of-contents">기타</a></li><li class="menu__list-item"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/reading_books_record_repository/docs/intro">책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">코어 자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-1">🌈 Chapter 1: 데이터 타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-2">🌈 Chapter 2: 실행 컨텍스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-3">🌈 Chapter 3: this</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-4">🌈 Chapter 4: 콜백 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-5">🌈 Chapter 5: 클로저</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-6">🌈 Chapter 6: 프로토타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/core-javascript/chapter-7">🌈 Chapter 7: 클래스</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">자바스크립트 코딩의 기술</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-1">1. 변수 할당으로 의도를 하라</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-2">2. 배열로 데이터 컬렉션을 관리하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-3">3. 특수한 컬렉션을 이용해 코드 명료성을 극대화하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-4">4. 조건문을 깔끔하게 작성하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-5">5. 반복문을 단순하게 만들어라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-6">6. 매개변수와 return 문을 정리하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-7">7. 유연한 함수를 만들어라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-8">8. 클래스로 인터페이스를 간결하게 유지하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-9">9. 외부 데이터에 접근하라.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/modern-javascript/chapter-10">10. 컴포넌트 아키텍처를 이용해 관련 파일을 모아라.</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">자바스크립트 패턴과 테스트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-1">🌈 Chapter 1: 좋은 소프트웨어 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-2">🌈 Chapter 2: 도구 다루기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-3">chapter-3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-4">🌈 Chapter 4: 패턴이 좋은 점</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-5">🌈 Chapter 5: 콜백 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-6">🌈 Chapter 6: 프라미스 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-7">🌈 Chapter 7: 부분 적용 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-8">🌈 Chapter 8: 메모이제이션 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-9">🌈 Chapter 9: 싱글톤 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-10">🌈 Chapter 10: 팩토리 패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/javascript/javascript-pattern-and-test/chapter-11">🌈 Chapter 11: 샌드박스 패턴</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">타입스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Do it! 타입스크립트 프로그래밍</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-1">1. 타입스크립트와 개발 환경 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-2">2. 타입스크립트 프로젝트 생성과 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-3">3. 객체와 타입</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-4">4. 함수와 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-5">5. 배열과 튜플</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-6">6. 반복기 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-7">7. Promise와 async/await 구문</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-8">8. 함수 조합의 원리와 응용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-9">9. 람다 라이브러리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-10">10. 제네릭 타입 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-11">11. 모나드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/typescript/do-it-typescript/chapter-12">12. 타입스크립트 함수형 프로그래밍 실습</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">애자일</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">클린 애자일</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-1">👉 Chapter 1: 애자일 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-2">👉 Chapter 2: 왜 애자일인가</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-3">👉 Chapter 3: 비즈니스 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-4">👉 Chapter 4: 팀 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-5">👉 Chapter 5: 기술 실천 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-6">👉 Chapter 6: 애자일해지기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/clean-agile/chapter-7">👉 Chapter 7: 장인 정신</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">린 UX</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-1">🌈 왜 린 UX인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-2">🌈 기본 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-3">🌈 비전 정의와 실행 계획, 성과</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-4">🌈 협업기반 디자인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-5">🌈 MVP와 실험</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-6">🌈 조사와 피드백</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-7">🌈 애자일과 린 UX의 통합</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/lean-ux/chapter-8">🌈 조직 변화 만들기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">The Nature of Software Development</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-1">1. 가치 찾기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-2">2. 가치, 우리가 원하는 것</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-3">3. 피처 단위 개발을 위한 가이드라인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-4">4. 피처 단위로 조직 구성하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-5">5. 피처 단위로 계획하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-6">6. 피처 단위로 개발하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-7">7. 피처와 기반을 동시에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-8">8. 무결점과 견고한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-9">9. 요약</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-10">10. 가치에 대해서</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-11">11. 가치를 정하는 기준</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-12">12. 물론 힘들 일입니다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-13">13. 그리 단순하지 않습니다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-14">14. 성장하는 개발팀 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-15">15. 초기 계획을 위한 &#x27;파이브 카드&#x27;</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-16">16. 경영진을 위한 소프트웨어 개발의 본질</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-17">17. 더 강한 채찍질</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-18">18. 속도를 내기 위한, 특별한 빌드 기술</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-19">19. 리팩토링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-20">20. 애자일 방법들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/nature-of-software-development/chapter-21">21. 애자일 확장</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">함께 자라기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-1">🌈 Chapter 1: 자라기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-2">🌈 Chapter 2: 함께</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/agile/growing-up-together/chapter-3">🌈 Chapter 3: 애자일</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">객체지향</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-1">🌈 Chapter 1: 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-2">🌈 Chapter 2: 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-3">🌈 Chapter 3: 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-4">🌈 Chapter 4: 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-5">🌈 Chapter 5: 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-6">🌈 Chapter 6: 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/facts-and-misunderstandings/chapter-7">🌈 Chapter 7: 함께 모으기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-1">🌈 Chapter 1: 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-2">🌈 Chapter 2: 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-3">🌈 Chapter 3: 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-4">🌈 Chapter 4: 설계 품질과 트레이드오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-5">🌈 Chapter 5: 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-6">🌈 Chapter 6: 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-7">🌈 Chapter 7: 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-8">🌈 Chapter 8: 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-9">🌈 Chapter 9: 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-10">🌈 Chapter 10: 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-11">🌈 Chapter 11: 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-12">🌈 Chapter 12: 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-13">🌈 Chapter 13: 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-14">🌈 Chapter 14: 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/object/chapter-15">🌈 Chapter 15: 디자인 패턴과 프레임워크</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">루비로 배우는 객체지향 디자인</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-1">✌️ Chapter 1: 객체지향 디자인</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-2">✌️ Chapter 2: 단일 책임 원칙을 따르는 클래스 디자인하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-3">✌️ Chapter 3: 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-4">✌️ Chapter 4: 유연한 인터페이스 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-5">✌️ Chapter 5: 오리 타입으로 비용 줄이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-6">✌️ Chapter 6: 상속을 이용해 새로운 행동 얻기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-7">✌️ Chapter 7: 모듈을 통한 역할 공유</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-8">✌️ Chapter 8: 조합을 이용해 객체 통합하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/design-in-ruby/chapter-9">✌️ Chapter 9: 비용-효율적인 테스트 디자인하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">엘레강트 오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/elegant-object/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-1">🌈 Chapter 1: Birth</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-2">🌈 Chapter 2: Education</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-3">🌈 Chapter 3: Employment</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/elegant-object/chapter-4">🌈 Chapter 4: Retirement</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">테스트 주도 개발로 배우는 객체 지향 설계와 실천</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-1">1. 테스트 주도 개발의 핵심은 무엇인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-2">2. 객체를 활용한 테스트 주도 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-3">3. 도구 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-4">4. 테스트 주도 주기 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-5">5. 테스트 주도 개발 주기의 유지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-6">6. 객체 지향 스타일</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-7">7. 객체 지향 설계의 달성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-8">8. 서드 파티 코드를 기반으로 한 개발</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-9">9. 경매 스나이퍼 개발 의뢰</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-10">10. 동작하는 골격</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-11">11. 첫 테스트 통과하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-12">12. 입찰 준비</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-13">13. 스나이퍼가 입찰하다</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-14">14. 스나이퍼가 경매에서 낙찰하다</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-15">15. 실제 사용자 인터페이스를 향해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-16">16. 여러 품목에 대한 스나이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-17">17. Main 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-18">18. 세부 사항 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-19">19. 실패 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-20">20. 테스트에 귀 기울이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-21">21. 테스트 가독성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-22">22. 복잡한 테스트 데이터 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-23">23. 테스트 진단</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/object-oriented/growing-object-oriented-software-guided-by-tests/chapter-24">24. 테스트 유연성</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">함수형</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">스칼라로 배우는 함수형 프로그래밍</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-1">🍭 Chapter 1: 함수형 프로그래밍이란 무엇인가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-2">🍭 Chapter 2: 스칼라로 함수형 프로그래밍 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-3">🍭 Chapter 3: 함수적 자료구조</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/in-scala/chapter-4">🍭 Chapter 4: 예외를 이용하지 않은 오류 처리</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">함수형 자바스크립트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/chapter-1">🌈 Chapter 1: 함수형 길들이기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/chapter-7">🌈 Chapter 7: 함수형 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/functional/functional-javascript/chapter-8">🌈 Chapter 8: 비동기 이벤트와 데이터를 관리</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">클린코드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">클린 코드: 애자일 소프트웨어 장인 정신</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-1">🍭 Chapter 1: 깨끗한 코드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-2">🍭 Chapter 2: 의미있는 이름</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-3">🍭 Chapter 3: 함수</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-4">🍭 Chapter 4: 주석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-5">🍭 Chapter 5: 형식 맞추기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-6">🍭 Chapter 6: 객체와 자료 구조</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-7">🍭 Chapter 7: 오류 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-8">🍭 Chapter 8: 경계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-9">🍭 Chapter 9: 단위 테스트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-10">🍭 Chapter 10: 클래스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-11">🍭 Chapter 11: 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-12">🍭 Chapter 12: 창발성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/clean/clean-code/chapter-13">🍭 Chapter 13: 동시성</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">기타</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/table-of-contents">🚀 책 목록</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-1">🤔 Chapter 1: 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-2">🤔 Chapter 2: 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-3">🤔 Chapter 3: 기본 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-4">🤔 Chapter 4: 실용주의 편집증</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-5">🤔 Chapter 5: 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-6">🤔 Chapter 6: 동시성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-7">🤔 Chapter 7: 코딩하는 동안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-8">🤔 Chapter 8: 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-9">🤔 Chapter 9: 실용주의 프로젝트</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">인스파이어드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/inspired/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/inspired/part-1">👉 Part 1. 최고의 기술 기업에서 배운 것</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/inspired/part-2">👉 Part 2. 사람</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Pro Git 2판</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/table-of-contents">🚀 목차</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/chapter-1">🌈 Chapter 1: 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/chapter-2">🌈 Chapter 2: Git의 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/reading_books_record_repository/docs/etc/pro-git-2/chapter-3">🌈 Chapter 3: Git 브랜치</a></li></ul></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">🤔 Chapter 5: 구부러지거나 부러지거나</h1></header><p>현대의 미친 듯이 빠른 변화 속도를 따라가려면 모든 수단을 동원하여 가능한 한 느슨하고 유연한 코드를 작성해야 한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-topic-28-결합도-줄이기"></a>🍭 Topic 28. 결합도 줄이기<a class="hash-link" href="#-topic-28-결합도-줄이기" title="Direct link to heading">#</a></h2><p>결합도가 높으면 이리저리 연결되어 있어서 여러 가지를 동시에 바꿔야 한다. 그래서 바꾸기 더 어려워진다. 여러분의 운명은 둘 중 하나다. 바꿔야 하는 곳을 모두 찾아내느라 시간을 들이거나, 아니면 &quot;딱 하나만&quot; 바꾸고 결합된 다른 것들은 잊은 채 왜 프로그램이 죽는지 고민하느라 시간을 들이거나.   </p><p>소프트웨어 구조는 유연해야 한다. 그리고 유연하려면 각각의 부품이 다른 부품에 가능한 한 조금만 연결되어야 한다.</p><blockquote><p><strong>Tip 44. 결합도가 낮은 코드가 바꾸기 쉽다.</strong></p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-열차-사고"></a>🥕 열차 사고<a class="hash-link" href="#🥕-열차-사고" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void applyDiscount(customer, order_id, discount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  totals = customer</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .orders</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .find(order_id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    getTotals();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  totals.grandTotal = totals.grandTotal - discount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  totals.discount = discount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 코드는 합계까지 다섯 단계의 추상화를 오간다. 결국 최상위 코드가 모든 것을 알아야 한다. 코드를 쓰거나 이해하기 위해 알아야 하는 것이 너무 많다. 설상가상으로 이 코드를 계속 지원하기 위해서 <strong>앞으로 바꾸면 안 되는 것</strong>도 너무 많다.</p><blockquote><p><strong>Tip 45. 묻지 말고 말하라(Tell, Don&#x27;t Ask)</strong></p></blockquote><p>이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 그 개체를 갱신해서는 안 된다는 것이다. 객체의 내부 상태를 묻는 것으로 인하여 캡슐화의 장점은 완전히 사라지고, 또 그 과정에서 구현에 대한 지식이 코드 여기저기로 퍼져 버린다. 따라서 우리 열차 사고를 고치는 첫 발짝은 할인 처리를 <code>totals</code> 객체에 위임하는 것이다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void applyDiscount(customer, order_id, discount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  customer</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .orders</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .find(order_id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .getTotals()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .applyDiscount(discount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>주문 컬렉션을 가져와서 주문을 찾아서는 안 된다. 고객 객체에서 바로 주문 객체를 얻어 와야 한다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void applyDiscount(customer, order_id, discount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  customer</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .findOrder(order_id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .getTotals()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .applyDiscount(discount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>마찬가지 논리를 주문 객체와 합계에도 적용할 수 있다. 주문 객체를 구현할 때 합계를 별도의 객체에 저장했다는 사실은 왜 온 세상 사람들이 알아야 하겠는가?</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void applyDiscount(customer, order_id, discount) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  customer</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .findOrder(order_id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    .applyDiscount(discount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데메테르-법칙디미터-법칙-law-of-demeter"></a>데메테르 법칙(디미터 법칙, Law of Demeter)<a class="hash-link" href="#데메테르-법칙디미터-법칙-law-of-demeter" title="Direct link to heading">#</a></h4><blockquote><p><strong>Tip 46. 메서스 호출을 역지 말라.</strong></p></blockquote><p>무언가에 접근할 때 &quot;.&quot;을 딱 하나만 쓰려고 노력해 보라. &quot;무언가에 접근&quot;한다는 건 중간 변수를 사용하는 경우까지 포함해야 한다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain"># 좋지 않은 방식이다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">amount = customer.orders.last().totals().amount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"># 마찬가지로 좋지 않다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">orders = customer.orders;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">last = orders.last();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">totals = last.totals();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">amount = totals.amount;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>점 하나 규칙에는 큰 예외가 하나 있다. 엮는 것들이 절대로 바뀌지 않을 것 같다면 이 규칙을 지키지 않아도 된다. 언어에 기본으로 포함된 라이브러리는 아마 꽤 안정적일 것이고, 다음과 같이 써도 될 것이다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">people</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .sort_by { |person| person.age }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .first(10)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  .map {| person | person.name }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="연쇄와-파이프라인"></a>연쇄와 파이프라인<a class="hash-link" href="#연쇄와-파이프라인" title="Direct link to heading">#</a></h4><p>파이프라인은 함수에서 함수로 데이터를 넘겨 가며 데이터를 변환한다. 이런 파이프라인은 메서드 호출로 이루어진 열차 사고와는 다르다. 숨겨진 구현 세부 사항에 의존하지 않기 때문이다.   </p><p>그렇다고 파이프라인이 결합을 하나도 만들지 않는 것은 아니다. 파이프라인의 함수에서 반환하는 데이터는 반드시 다음 함수가 처리할 수 있는 형식이어야 한다.   </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-글로벌화의-해악"></a>🥕 글로벌화의 해악<a class="hash-link" href="#🥕-글로벌화의-해악" title="Direct link to heading">#</a></h3><p>어디서나 접근할 수 있는 데이터는 교묘하게 애플리케이션 컴포넌트 간의 결합을 만들어 낸다. 전역 데이터 하나하나는 애플리케이션의 모든 메서드에 갑자기 매개 변수가 추가된 것과 같은 효과를 낸다. 전역 데이터는 <strong>모든</strong> 메서드 안에서 사용할 수 있으니 말이다.   </p><p>전역 데이터는 여러 가지 방법으로 코드의 결합도를 높인다. 전역 데이터의 구현을 변경할 때 시스템 코드 전체에 영향을 줄 수 있음은 분명하다.   </p><p>전역 데이터는 코드를 떼어 내는 경우에도 문제를 만든다. 코드를 재사용할 수 있도록 해야 한다는 생각이 코딩 습관이 일부가 되어야 한다. 코드를 재사용할 수 있도록 하려면 깨끗한 인터페이스를 만들고 나머지 코드와의 결합을 없애야 한다. 그래야 나머지 것들이 우르르 딸려 들어오는 일 없이 메서드나 모듈을 뽑아낼 수 있다.   </p><p>전역 데이터를 쓰는 코드에 단위 테스트를 만들다 보면 이런 문제를 발견하게 된다. 그저 테스트를 실행하려는 것뿐인데 전역 환경을 생성하는 코드를 한참이나 써야 한다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="싱글턴singleton도-전역-데이터다"></a>싱글턴(singleton)도 전역 데이터다<a class="hash-link" href="#싱글턴singleton도-전역-데이터다" title="Direct link to heading">#</a></h4><p>앞에서 우리는 일부러 <strong>전역 변수</strong>가 아니라 <strong>전역 데이터</strong>라고 계쏙 말했다. 가끔씩 &quot;이것 보세요. 전역 변수는 없어요. 모두 인스턴스 데이터로 싱글턴이나 전역 모듈 안에 넣었어요.&quot;라고 말하는 사람이 있기 때문이다.   </p><p>여러분의 코드에 있는 것이 싱글턴뿐이더라도, 외부로 노출된 인스턴스 변수가 잔뜩 있는 싱글턴은 여전히 전역 데이터다. 그저 이름이 좀 길어졌을 뿐이다.   </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="외부-리소스도-전역-데이터다"></a>외부 리소스도 전역 데이터다<a class="hash-link" href="#외부-리소스도-전역-데이터다" title="Direct link to heading">#</a></h4><p>수정 가능한 외부 리소스는 모두 전역 데이터다. 여러분의 애플리케이션이 데이터베이스나 저장소, 파일 시스템, 서비스 API 등을 사용한다면 전역 데이터의 함정에 빠질 위험이 있는 것이다. 여기서도 해법은 반드시 이 리소스들을 여러분이 작성하는 코드로 모두 감싸는 것이다.</p><blockquote><p><strong>Tip 48. 전역적이어야 할 만큼 중요하다면 API로 감싸라.</strong></p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-상속은-결합을-늘린다"></a>🥕 상속은 결합을 늘린다<a class="hash-link" href="#🥕-상속은-결합을-늘린다" title="Direct link to heading">#</a></h3><p>상속으로 다른 클래스의 상태와 행동을 그대로 가져올 수 있다. 상속을 잘못 사용하는 문제는 너무 중요해서 별도로 항목을 만들었다. (항목 31. 상속세 참고)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-결국은-모두-etc"></a>🥕 결국은 모두 ETC<a class="hash-link" href="#🥕-결국은-모두-etc" title="Direct link to heading">#</a></h3><p>결합된 코드는 바꾸기 힘들다. 코드의 한 곳을 바꾸면 다른 곳에 여파가 미칠 수 있다. 가끔은 찾기 힘든 곳에 문제가 생기는 바람에 한 달 후에나 서비스에 오류가 발생하면서 문제의 실상이 드러나기도 한다.   </p><p>직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라. 그러면 애플리케이션의 결합도를 낮게 유지할 수 있을 것이고, 결과적으로 코드를 바꾸기 쉬워질 것이다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-topic-29-실세계를-갖고-저글링하기"></a>🍭 Topic 29. 실세계를 갖고 저글링하기<a class="hash-link" href="#-topic-29-실세계를-갖고-저글링하기" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-이벤트"></a>🥕 이벤트<a class="hash-link" href="#🥕-이벤트" title="Direct link to heading">#</a></h3><p>이벤트는 무언가 정보가 있다는 것을 의미한다. 정보는 사용자가 버튼을 클릭하거나, 주가 정보가 갱신될 때처럼 외부에서 올 수 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-유한-상태-기계"></a>🥕 유한 상태 기계<a class="hash-link" href="#🥕-유한-상태-기계" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="실용주의-fsm-해부학"></a>실용주의 FSM 해부학<a class="hash-link" href="#실용주의-fsm-해부학" title="Direct link to heading">#</a></h4><p>기본적으로 상태 기계는 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다. 정해진 상태들이 있고 그중 하나가 &quot;현재 상태&quot;다. 상태마다 그 상태일 때 의미가 있는 이벤트들을 나열하고, 이벤트별로 시스템의 다음 &quot;현재 상태&quot;를 정의한다.   </p><p>FSM의 멋진 점은 FSM을 오로지 데이터만으로 표현할 수 있다는 것이다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="행동-추가하기"></a>행동 추가하기<a class="hash-link" href="#행동-추가하기" title="Direct link to heading">#</a></h4><p>특정한 상태 이행이 일어날 떄 수행하는 행동을 추가하여 FSM을 더 강력하게 만들 수 있다.   </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상태-기계는-시작일-뿐"></a>상태 기계는 시작일 뿐<a class="hash-link" href="#상태-기계는-시작일-뿐" title="Direct link to heading">#</a></h4><p>상태 기계는 개발자들에게 저평가되어 있다. 여러분이 상태 기계를 적용할 수 있는 곳을 한번 찾아보면 좋겠다. 하지만 상태 기계가 이벤트와 관련된 모든 문제를 해결하지는 못한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-감시자-패턴"></a>🥕 감시자 패턴<a class="hash-link" href="#🥕-감시자-패턴" title="Direct link to heading">#</a></h3><p>감시자 패턴은 이벤트를 발생시키는 쪽인 감시 대상과 이런 이벤트에 관심이 있는 클라이언트인 감시자로 이루어진다.<br>
감시자는 자신이 관심 있는 이벤트를 감시 대상에 등록한다. 보통은 호출될 함수의 참조도 등록할 때 함께 넘긴다. 나중에 해당 이벤트가 발생하면 감시 대상은 등록된 감시자 목록을 보면서 함수들을 일일이 호출한다. 이때, 발생한 이벤트를 감시자 함수의 인자로 넘긴다.   </p><p>감시 대상을 만드는 코드는 별게 없다. 함수 참조를 리스트에 추가하고, 이벤트가 일어나면 이 함수들을 호출한다.   </p><p>&quot;감시자-감시 대상&quot; 패턴은 수십 년간 쓰여 왔고, 잘 작동했다. 특히 사용자 인터페이스 시스템에서 널리 쓰이는데, 어떤 상호 작용이 일어났다는 것을 애플리케이션에 콜백으로 알려주는 방식을 사용한다.   </p><p>하지만 감시자 패턴에는 문제가 하나 있다. 모든 감시자가 감시 대상에 등록을 해야 하기 때문에 결합이 생긴다. 더군다나 일반적으로 감시 대상이 콜백을 직접 호출하도록 구현하기 때문에 이 부분이 성능 병목이 될 수 있다.<br>
동기적 처리의 특성상 콜백 실행이 끝날 때까지 감시 대상이 계속 기다려야 하기 때문이다. 이 문제는 다음 전략인 &quot;게시-구독&quot;으로 해결한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-게시-구독"></a>🥕 게시-구독<a class="hash-link" href="#🥕-게시-구독" title="Direct link to heading">#</a></h3><p>게시-구독 혹은 발행-구독 모델은 줄여서 펍섭이라고도 부르며 감시자 패턴을 일반화한 것이다. 동시에 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결한다.   </p><p>게시-구독 모델에는 게시자와 구독자가 있고, 이들은 채널로 연결된다. 채널은 별도 코드로 구현되는데, 이런 상세한 구현 내용은 여러분의 코드로부터 숨겨져 있다.   </p><p>각 채널에는 이름이 있다. 구독자는 관심사를 하나 이상의 채널에 등록하고, 게시자는 채널에 이벤트를 보낸다. 감시자 패턴과는 다르게 게시자와 구독자 사이의 통신은 여러분의 코드 밖에서 일어난다. 아마 비동기적으로 이루어질 것이다.   </p><p>게시-구독 모델은 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋은 기술이다. 대신 단점은 게시-구독 모델을 아주 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기가 힘들다는 것이다. 게시자가 메시지를 보내는 것을 확인했더라도 어떤 구독자가 그 메시지를 처리하는지 바로 이어서 볼 수 없다.   </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-반응형-프로그래밍과-스트림-그리고-이벤트"></a>🥕 반응형 프로그래밍과 스트림 그리고 이벤트<a class="hash-link" href="#🥕-반응형-프로그래밍과-스트림-그리고-이벤트" title="Direct link to heading">#</a></h3><p>어떤 셀에 들어 있는 수식에서 다른 셀을 참조하고 있을 때, 참조된 셀의 값을 바꾸면 첫 번째 셀의 값도 바뀐다. 값이 바뀌면 그 값을 사용하는 다른 값이 &quot;반응하는&quot; 것이다.<br>
이런 데이터 수준의 반응성을 구현할 수 있는 프레임워크가 많이 있다. 브라우저 세계에서는 현재 리액트와 뷰의 인기가 가장 높다.   </p><p>이벤트를 사용하여 코드가 반응하도록 할 수 있다는 것은 명백하다. 하지만 이벤트를 이리저리 연결하는 것도 쉽지많은 않다. 그래서 스트림이 필요하다.   </p><p>스트림은 이벤트를 일반적인 자료 구조처럼 다룰 수 있게 해 준다. 이벤트의 리스트를 다룬다고 생각하면 된다. 새로운 이벤트가 도착하면 이 리스트가 길어지는 셈이다. 이런 방식이 좋은 이유는 익숙한 방식으로 스트림을 다룰 수 있기 때문이다. 이벤트를 처리하고, 조합하고, 골라내는 등 우리가 아는 온갖 작업을 일반적인 자료 구조와 마찬가지 방법으로 할 수 있다. 심지어 이벤트 스트림과 일반 자료 구조를 조합할 수도 있다. 또한 스트림은 비동기적으로 작동할 수도 있는데, 이벤트가 도착했을 때 여러분의 코드가 이벤트에 응답할 기회를 얻는다.   </p><p>첫 번째 예제는 두 개의 스트림을 받아서 하나로 엮는다. 그러면 결과로 새로운 스트림이 생기는데, 첫 번재 스트림에서 원소 하나, 두 번째 스트림에서 원소 하나를 가져와서 하나로 묶은 것이 새로운 스트림의 원소가 된다. 다음 예에서 첫 번째 스트림은 그냥 동물 이름 다섯 개다. 두 번째 스트림은 좀 더 흥미로운데, 500ms마다 이벤트를 발생시키는 반복 타이머다. 두 스트림이 집으로 엮였기 때문에 둘 모두에 데이터가 있을 때만 엮인 스트림에 결과가 생긴다. 즉, 출력 스트림은 0.5초에 한 번씩 결과를 내보낸다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly js"><pre tabindex="0" class="prism-code language-js codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token keyword module" style="color:#00009f">import</span><span class="token plain"> </span><span class="token imports operator" style="color:#393A34">*</span><span class="token imports"> </span><span class="token imports keyword module" style="color:#00009f">as</span><span class="token imports"> </span><span class="token imports maybe-class-name">Observable</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;rxjs&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">import</span><span class="token plain"> </span><span class="token imports punctuation" style="color:#393A34">{</span><span class="token imports"> logValues </span><span class="token imports punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;../rxcommon/logger.js&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> animals </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token maybe-class-name">Observable</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">of</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;ant&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;bee&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;cat&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;dog&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;elk&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> ticker </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token maybe-class-name">Observable</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">interval</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">500</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> combined </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token maybe-class-name">Observable</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">zip</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">animals</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> ticker</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">combined</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">subscribe</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">next</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">logValues</span><span class="token punctuation" style="color:#393A34">(</span><span class="token known-class-name class-name">JSON</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">stringify</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">next</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>위 코드는 브라우저 창의 목록에 새로운 항목을 추가하는 간단한 로깅 함수를 사용한다. 각 항목에는 프로그램이 시작된 후부터 흐른 시간을 밀리초 단위로 붙인다. 500ms마다 하나씩 스트림에서 이벤트를 받고 있다. 브라우저에서 실행해 보면 로그 항목이 정확하게 0.5초마다 나타난다.   </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-어디에나-이벤트가-있다"></a>🥕 어디에나 이벤트가 있다<a class="hash-link" href="#🥕-어디에나-이벤트가-있다" title="Direct link to heading">#</a></h3><p>이벤트는 모든 곳에 있다. 몇 가지는 뻔하다. 마우스 버튼을 클릭하거나 타이머가 울린다. 하지만 그렇게 뻔하지 않은 경우도 있다. 누군가가 로그인하거나 파일의 특정 줄이 패턴과 일치한다. 하지만 이벤특 어디서 발생하든 이벤트를 중심으로 공들여 만든 코드는 일직선으로 수행되는 코드보다 더 잘 반응하고 결합도가 더 낮다.   </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-topic-30-변환-프로그래밍"></a>🍭 Topic 30. 변환 프로그래밍<a class="hash-link" href="#-topic-30-변환-프로그래밍" title="Direct link to heading">#</a></h2><p>모든 프로그램은 데이터를 변환한다. 받은 입력은 출력으로 바꾼다. 하지만 우리는 설계를 고민할 때 변환을 만드는 것에 대해서는 거의 생각하지 않는다. 오직 클래스와 모듈, 자료 구조, 알고리즘, 언어, 프레임워크에 대해서만 걱정할 뿐이다.   </p><p>우리는 이렇게 코드에만 집중하면 핵심을 놓칠 수 있다고 본다. 프로그램이란 입력을 출력으로 바꾸는 것이라는 사고방식으로 돌아갈 필요가 있다. 이렇게 생각하면 그동안 고민하던 많은 세부 사항이 모두 사라진다. 구조는 명확해지고 더 일관적으로 오류를 처리하게 되어 결합도 대폭 줄어들 것이다.   </p><blockquote><p><strong>Tip 49. 프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다.</strong></p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-변환-찾기"></a>🥕 변환 찾기<a class="hash-link" href="#🥕-변환-찾기" title="Direct link to heading">#</a></h3><p>때에 따라선 요구 사항에서 시작하는 게 변환을 찾는 가장 쉬운 방법이다. 요구 사항에서 입력과 출력이 무엇인지 찾으면 전체 프로그램을 나타내는 함수가 정해진다. 이제 입력을 출력으로 바꿔 가는 단계들을 찾으면 된다. 일종의 하향식 접근 방식이다.   </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-이것이-왜-그리-대단한가"></a>🥕 이것이 왜 그리 대단한가?<a class="hash-link" href="#🥕-이것이-왜-그리-대단한가" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">word</span></span><span class="token-line" style="color:#393A34"><span class="token plain">|&gt; all_subset_longer_than_three_characters()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">|&gt; sa_unique_signatures()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">|&gt; find_in_dictionary()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">|&gt; group_by_length()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>요구 사항을 달성하기 위해 필요한 것은 하나로 연결된 변환들뿐이다. 각각은 앞의 변환에서 입력을 받아 처리한 결과를 다음 변환으로 넘겨준다. 이보다 글처럼 읽기 쉬운 코드는 만들기 어려울 것이다.   </p><p>하지만 더 깊은 의미도 있다. 객체 지향 프로그래밍 경혐이 많다면 반사적으로 데이터를 숨기고, 객체 안에 캡슐화해야 한다고 느낄 것이다. 이런 객체들은 서로 이리저리 이야기하며 서로의 상태를 변경한다. 이런 방식은 결합을 많이 만들어 내고, 이는 결국 객체 지향 시스템이 바꾸기 어려워지는 큰 요인이 된다.</p><blockquote><p><strong>Tip 50. 상태를 쌓아 놓지 말고 전달하라.</strong></p></blockquote><p>변환 모델에서는 이런 사고를 근본적으로 뒤엎는다. 데이터를 전체 시스템 여기저기의 작은 웅덩이에 흩어 놓는 대신, 데이터를 거대한 강으로, 흐름으로 생각하라. 데이터는 기능과 동등해진다. 파이프라인은 코드 -&gt; 데이터 -&gt; 코드 -&gt; 데이터 ...의 연속이다. 데이터는 더 이상 클래스를 정의할 때처럼 특정한 함수들과 묶이지 않는다. 대신 우리 애플리케이션이 입력을 출력으로 바꾸어 나가는 진행 상황을 데이터로 자유롭게 표현할 수 있다. 이 말인즉슨 결합을 대폭 줄일 수 있다는 것이다. 어떤 함수든 매개 변수가 다른 함수의 출력 결과와 맞기만 하면 어디서나 사용하고 또 재사용할 수 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-오류-처리는-어떻게-하나"></a>🥕 오류 처리는 어떻게 하나.<a class="hash-link" href="#🥕-오류-처리는-어떻게-하나" title="Direct link to heading">#</a></h3><p>여러 가지 방법이 있지만 공통으로 사용하는 기본적인 관례가 하나 있다. 바로 변환 사이에 값을 절대 날것으로 넘기지 않는 것이다. 대신 래퍼 역할을 하는 자료 구조나 타입으로 값을 싸서 넘긴다. 이런 자료 구조나 타입은 안에 들어 있는 값이 유효한지를 추가로 알려 준다. 예를 들어 하스켈에서 이런 래퍼를 <code>Maybe</code>라고 부르고, F#과 스칼라에서는 <code>Option</code>이다.   </p><p>이런 개념을 어떻게 활용하는지는 언어에 따라 다르다. 하지만 코드 작성 방식은 기본적으로 크게 두 가지로 나뉜다. 오류 검사를 변환 안에서 하는 방식과 변환 바깥에서 하는 방식이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-변환은-프로그래밍을-변환한다"></a>🥕 변환은 프로그래밍을 변환한다<a class="hash-link" href="#🥕-변환은-프로그래밍을-변환한다" title="Direct link to heading">#</a></h3><p>코드를 일련의 (중첩된) 변환으로 생각하는 접근 방식은 프로그래밍을 해방시킨다. 익숙해지는 데는 시간이 좀 걸리지만, 일단 습관을 들이면 여러분의 코드가 더 명확해지고, 함수는 짧아지며, 설계는 단순해질 것이다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-topic-31-상속세"></a>🍭 Topic 31. 상속세<a class="hash-link" href="#-topic-31-상속세" title="Direct link to heading">#</a></h2><p>객체 지향 언어로 프로그래밍하는가? 상속을 사용하는가?<br>
그렇다면 멈춰라! 아마 여러분에게 필요한 것은 상속이 아닐 것이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-약간의-배경지식"></a>🥕 약간의 배경지식<a class="hash-link" href="#🥕-약간의-배경지식" title="Direct link to heading">#</a></h3><p>우리가 맞닥트린 객체 지향 개발자 세대는 다음 둘 중 하나의 이유로 상속을 사용한다. 타입이 싫어서 아니면 타입이 좋아서.   </p><p>타입을 싫어하는 이들은 입력하는 글자 수를 줄이기 위해 상속을 쓴다. 상속으로 공통 기능을 기반 클래스에서 자식 클래스로 넘기는 것이다. <code>User</code> 클래스와 <code>Product</code> 클래스는 모두 <code>ActiveRecord::Base</code>의 하위 클래스다.<br>
타입을 좋아하는 이들은 상속으로 클래스 간의 관계를 표현한다. <code>Car</code>는 <code>Vehicle</code>의 일종이다.<br>
안타깝지만 두 가지 상속 모두 문제가 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-코드를-공유하기-위해-상속을-쓸-때의-문제"></a>🥕 코드를 공유하기 위해 상속을 쓸 때의 문제<a class="hash-link" href="#🥕-코드를-공유하기-위해-상속을-쓸-때의-문제" title="Direct link to heading">#</a></h3><p>상속도 일종의 결합이다. 자식 클래스가 부모 클래스, 부모의 부모, 또 그 부모에게 연결되는 것은 물론이요, 자식 클래스를 사용하는 코드도 이 클래스의 모든 조상과 얽히게 된다. 다음 예를 보자.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Vehicle</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def initialize</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @speed = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def stop</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @speed = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def move_at(speed)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @speed = speed</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class Car &lt; Vehicle</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def info</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;#{@speed}의 속도로 주행 중인 차입니다.&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"># 최상위 코드</span></span><span class="token-line" style="color:#393A34"><span class="token plain">my_car = Car.new</span></span><span class="token-line" style="color:#393A34"><span class="token plain">my_car.move_at(30)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>최상위 코드에서 <code>my_car.move_at</code>을 호출하면 <code>Car</code>의 부모인 <code>Vehicle</code>의 메서드가 수행된다.<br>
<code>Vehicle</code> 담당 프로그래머사 API를 바꾼다고 해 보자. <code>move_at</code>은 <code>set_velocity</code>로, 인스턴스 변수 <code>@speed</code>는 <code>@velocity</code>로 바꾸었다.<br>
API가 바뀌면 <code>Vehicle</code> 클래스를 사용하는 클라이언트가 작동하지 않는 것은 당연하다. 하지만 앞에서 본 최상위 코드의 담당자는 코드가 작동하지 않아 깜짝 놀랄 것이다. 자신은 <code>Car</code>를 쓰고 있다고만 생각하기 때문이다. <code>Car</code> 클래스가 내부적으로 어떻게 구현되어 있는지는 사용자가 신경 쓸 부분이 아니지만, <code>Car</code>를 사용하는 코드까지 함꼐 망가지고 만다.   </p><p>비슷하게 인스턴스 변수의 이름은 온전히 내부 구현의 세부 사항이다. 하지만 <code>Vehicle</code>이 변수 이름을 바꾸자 어느새 <code>Car</code>가 망가졌다.<br>
결합이 너무 많다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-타입을-정의하기-위해-상속을-쓸-때의-문제"></a>🥕 타입을 정의하기 위해 상속을 쓸 때의 문제<a class="hash-link" href="#🥕-타입을-정의하기-위해-상속을-쓸-때의-문제" title="Direct link to heading">#</a></h3><p>클래스 사이의 아주 작은 미묘한 차이까지 잡아내서 표현하기 위해 계층 위에 계층을 덧붙이다 보면, 클래스 계층도는 순식간에 벽면 전체를 덮는 괴물로 자라난다. 이런 복잡도는 애플리케이션을 더 취약하게 만든다. 변경 사항이 위나 아래로 여러 단계에 걸쳐 영향을 미칠 수 있기 때문이다.   </p><blockquote><p><strong>Tip 51. 상속세를 내지 말라.</strong></p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-더-나은-대안"></a>🥕 더 나은 대안<a class="hash-link" href="#🥕-더-나은-대안" title="Direct link to heading">#</a></h3><p>더는 상속을 쓸 필요가 없게 해 주는 세 가지 기법을 소개하겠다.</p><ul><li>인터페이스와 프로토콜</li><li>위임 믹스인과 트레이트</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인터페이스와-프로토콜"></a>인터페이스와 프로토콜<a class="hash-link" href="#인터페이스와-프로토콜" title="Direct link to heading">#</a></h4><p>대부분의 객체 지향 언어는 클래스가 특정한 동작을 구현한다고 지정할 수 있다. 여러 동작을 지정할 수도 있는데, 예를 들어 <code>Car</code> 클래스가 <code>Drivable</code> 동작과 <code>Locatable</code> 동작을 구현한다고 할 수 있다. 문법은 언어마다 상이한다. 자바에서는 다음과 같다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public class Car implements Drivable, Locatable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Car 클래스의 코드, 이 코드는 Drivable과 Locatable이</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 요구하는 기능을 모두 구현해야 한다.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>Drivable</code>과 <code>Locatable</code> 같은 자바에서는 인터페이스라고 부른다. 프로토콜이라고 부르는 언어도 있고 트레이트라고 부르는 언어도 있다.<br>
인터페이스는 다음과 같이 정의한다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Drivable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  double getSpeed();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  void stop();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Locatable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  Coordinate getLocation();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  boolean locationIsValid();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 선언들은 아무런 코드도 만들지 않는다. 그냥 <code>Drivable</code>을 구현하는 클래스는 모두 <code>getSpeed</code>와 <code>stop</code> 두 개의 메서드를 구현해야 한다고 지시할 뿐이다. <code>Locatable</code>한 클래스는 <code>getLocation</code>과 <code>locationIsValid</code>를 구현해야 한다.   </p><p>인터페이스나 프로토콜이 강력한 까닭은 이들을 타입으로 사용할 수 있고, 해당 인터페이스를 구현하는 클래스라면 무엇이든 그 타입과 호환되기 떄문이다. 만약 <code>Car</code>와 <code>Phone</code>이 모두 <code>Locatable</code> 인터페이스를 구현했다면 둘 다 <code>Locatable</code>한 것을 담는 리스트에 넣을 수 있다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Locatable&gt; items = new ArrayList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">items.add(new Car(...));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">items.add(new Phone(...));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">items.add(new Car(...));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이 리스트를 처리할 때는 모든 원소가 <code>getLocation</code>과 <code>locationIsValid</code>를 구현했다는 것을 알고 있으므로 이를 활용할 수 있다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">void printLocation(Locatable item) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (item.locationIsValid()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    print(item.getLocation().asString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">items.forEach(printLocation);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><p><strong>Tip 52. 다형성은 인터페이스로 표현하는 것이 좋다.</strong></p></blockquote><p>인터페이스와 프로토콜은 상속 없이도 다형성을 가져다준다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="위임"></a>위임<a class="hash-link" href="#위임" title="Direct link to heading">#</a></h4><p>상속은 개발자들이 점점 더 메서드가 많은 클래스를 만들도록 유도한다. 부모 클래스에 메서드가 20개 있으면 하위 클래스는 그중 딱 두 개만 사용하고 싶더라도 필요 없는 18개의 메서드까지 함께 따라와서 자리를 차지하고 호출되기만을 기다린다. 클래스가 자신의 인터페이스를 제어할 수 없게 되는 것이다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Account &lt; PersistenceBaseClass</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이제 <code>Account</code> 클래스는 영속성 클래스 API를 모두 달고 다녀야 한다. 이러는 대신 다음과 같이 위이믈 사용하면 어떨지 생각해 보라.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Account</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def initialize(. . .)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @repo = Persister.for(self)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def save</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @repo.save()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이제 <code>Account</code> 클래스는 클라이언트에게 프레임워크의 API를 전혀 노출하지 않는다. 결합이 사라진 것이다. 그뿐 아니라 우리는 더 이상 우리가 사용하는 프레임워크를 API에 제약을 받지 않고, 필요한 API를 마음대로 만들 수 있다. 클라이언트가 우리가 추가한 인터페이스는 건너뛰고 상속받는 영속성 API를 사용할 위험이 있었다. 이제는 우리가 모든 것을 제어한다.</p><blockquote><p><strong>Tip 53. 서비스에 위임하라. Has-A가 Is-A보다 낫다.</strong></p></blockquote><p><code>Account</code>가 왜 영속성에 관해 알아야하겠는가? <code>Account</code> 클래스는 계정에 관한 비즈니스 규칙을 적용하는 것이 원래 할 일 아닌가?</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class Account</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  # 계정에 관련된 일만 함</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class AccountRecord</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  # Account를 감싸서 객체를 저장하거나 불러오는 기능을 더함</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>이제는 진짜 결합이 사라졌다. 하지만 여기에는 계산서가 붙는다. 코드를 더 많이 써야 한다. 그중 일부는 틀에 박힌 코드일 것이다. 예를 들어 아마 모든 레코드 클래스에 &quot;찾기&quot; 메서드가 필요할 테니 일일이 메서드를 추가해 주어야 한다.   </p><p>다행히도 믹스인과 트레이트가 하는 일이 바로 이것이다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="믹스인-트레이트-카테고리-프로토콜-확장-등"></a>믹스인, 트레이트, 카테고리, 프로토콜 확장 등<a class="hash-link" href="#믹스인-트레이트-카테고리-프로토콜-확장-등" title="Direct link to heading">#</a></h4><p>믹스인의 기본 발상은 단순하다. 클래스나 객체에 상속을 사용하지 않고 새로운 기능을 추가하여 확장하고 싶다. 그래서 일련의 함수들을 만들고, 여기에 이름을 붙인 다음, 이것으로 어떻게든 클래스나 객체를 확장한다. 이 시점에서 여러분은 기존 클래스와 그에 덧붙이는 믹스인의 동작을 모두 합한 새로운 클래스나 객체를 만든 것이다. 대부분의 경우 확장하려는 클래스의 소스 코드에 접근할 수 없더라도 이런 확장을 만들 수 있다.   </p><p>이 기능을 구현했을 때 할 수 있는 일, 바로 기존의 것과 새로운 것의 기능 집합을 합치는 것이다.   </p><p>앞의 <code>AccountRecord</code> 예제에서 <code>AccountRecord</code>가 계정과 영속성 프레임워크를 모두 알아야 한다고 하고선 멈추었다. 영속성 계층에서 제공하는 메서드 중 바깥세상에 노출해야 하는 것들을 일일이 위임하는 일도 해야 한다.   </p><p>믹스인이 대안을 제시한다. 예를 들어 영속성 계층의 찾기 메서드 세 가지 중 두 가지만을 구현하는 믹스인을 만든다고 하자. 그런 다음 <code>AccountRecord</code>에 이 믹스인을 추가할 수 있다. 그리고 <code>Account</code> 말고 다른 객체를 저장하기 위해 새로운 클래스를 만들 때도 이 믹스인을 사용할 수 있다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">mixin CommonFinders {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def find(id) { ... }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  def findAll() { ... }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class AccountRecord extends BasicRecord with CommonFinders</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class OrderRecord extends BasicRecord with CommonFinders</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>여기서 더 발전시킬 수 있다. 예를 들어 우리 시스템에 나쁜 데이터가 끼어 들어오는 것을 막아야 하므로 당연히 비즈니스 객체에 검증 코드가 필요하다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly ruby"><pre tabindex="0" class="prism-code language-ruby codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">class AccountForCustomer extends Account with AccountValidations, AccountCustomerValidations</span></span><span class="token-line" style="color:#393A34"><span class="token plain">class AccountForAdmin extends Account with AccountValidations, AccountCustomerValidations</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>여기서는 두 파생 클래스 모두 계정 객체에 공통으로 적용해야 할 검증을 포함하고 있다. 고객용 클래스인 <code>AccountForCustomer</code>는 고객이 사용하는 API에 적합한 검증을 추가로 포함하고 있고, 관리자용 클래스인 <code>AccountForAdmin</code>은 아마 제한이 더 느슨할 관리자용 검증을 추가로 포함하고 있다.<br>
이제 <code>AccountForCustomer</code>와 <code>AccountForAdmin</code>의 인스턴스를 이리저리 넘길때 자동으로 정확한 검증을 수행하리라 보장할 수 있다.</p><blockquote><p><strong>Tip 54. 믹스인으로 기능을 공유하라.</strong></p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-상속이-답인-경우는-드물다"></a>🥕 상속이 답인 경우는 드물다<a class="hash-link" href="#🥕-상속이-답인-경우는-드물다" title="Direct link to heading">#</a></h3><p>타입 정보를 공유하고 싶은 건지, 기능을 더하고 싶은 건지, 메서드를 공유하고 싶은 건지에 따라 다르다. 프로그래밍의 다른 모든 것과 마찬가지로 여러분의 목표는 의도를 가장 잘 드러내는 기법을 사용하는 것이어야 한다.<br>
그리고 정글 전체를 끌어들이지 않도록 조심하라.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-topic-32-설정"></a>🍭 Topic 32. 설정<a class="hash-link" href="#-topic-32-설정" title="Direct link to heading">#</a></h2><p>애플리케이션이 출시된 이후 바뀔 수도 있는 값에 코드가 의존하고 있다면 그 값을 애플리케이션 외부에서 관리하라. 여러분의 애플리케이션이 여러 환경에서 혹은 여러 고객을 위해 실행된다면 특정 환경이나 특정 고객에게 한정된 값을 애플리케이션 외부에서 관리하라. 이렇게 하면 여러분은 애플리케이션을 조정할 수 있게 된다. 코드가 자신이 실행되는 환경에 적응하는 것이다.</p><blockquote><p><strong>Tip 55. 외부 설정으로 애플리케이션을 조정할 수 있게 하라.</strong></p></blockquote><p>일반적으로 설정 데이터 안에 넣는 것은 다음과 같다.</p><ul><li>데이터베이스나 외부 API 같은 외부 서비스의 인증 정보</li><li>로그 레벨과 로그 저장 위치</li><li>애플리케이션이 사용하는 포트 번호, IP 주소, 기계나 클러스터 이름</li><li>특정 실행 환경에만 적용되는 검증 매개 변수</li><li>외부에서 지정하는 매개 변수. 예를 들어 배송비</li><li>지역에 따른 세부 서식</li><li>라이선스 키</li></ul><p>기본적으로 나중에 바뀌리라 알고 있는 것, 소스 코드 본체 바깥에 표현할 수 있는 것을 찾아라. 그리고 설정 더미에 던져 넣어라.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-정적-설정"></a>🥕 정적 설정<a class="hash-link" href="#🥕-정적-설정" title="Direct link to heading">#</a></h3><p>어떤 형태를 사용하든 여러분의 애플리케이션에서는 설정을 자료 구조 형태로 불러온다. 보통 처음 애플리케이션을 시작할 때 읽어올 것이다. 흔히 자료 구조를 전역에서 접근할 수 있도록 하는데, 코드의 어느 부분에서든 설정 정보에 쉽게 접근할 수 있도록 하기 위해서일 것이다.   </p><p>우리는 그렇게 하지 않기를 추천한다. 대신 설정 정보를 (얇은) API 뒤로 숨겨라. 그러면 설정을 표현하는 세부 사항으로부터 여러분의 코드를 떼어 놓을 수 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-서비스형-설정"></a>🥕 서비스형 설정<a class="hash-link" href="#🥕-서비스형-설정" title="Direct link to heading">#</a></h3><p>설정 정보를 애플리케이션 외부에서 관리하는 것은 동일하지만, 일반 파일이나 데이터베이스가 아니라 서비스 API 뒤에서 관리하는 것을 선호한다. 서비스형 설정에는 몇 가지 장점이 있다.</p><ul><li>여러 애플리케이션이 설정 정보를 공유할 수 있다.</li><li>여러 인스턴스에 걸쳐서 전체 설정을 한번에 바꿀 수 있다.</li><li>설정 데이터를 전용 UI로 관리할 수 있다.</li><li>설정 데이터를 동적으로 계속 바꿀 수 있다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="🥕-도도-코드를-작성하지-말라"></a>🥕 도도 코드를 작성하지 말라<a class="hash-link" href="#🥕-도도-코드를-작성하지-말라" title="Direct link to heading">#</a></h3><p>외부 설정을 사용하지 않는다면 코드는 적응성이나 유연성을 어느 정도 포기해야만 한다. 이것이 얼마나 나쁜 일일까? 글쎄, 프로그램의 세계에서 잠시 벗어나 실제 세상의 이야기를 하자면 환경에 적응하지 못하는 생물은 멸종한다.<br>
여러분의 프로젝트가, 여러분의 경력이 도도의 전철을 밟지 않도록 하라.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/saseungmin/reading_books_record_repository/tree/master/docs/etc/pragmatic-programmer/chapter-5.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-4"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 🤔 Chapter 4: 실용주의 편집증</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/reading_books_record_repository/docs/etc/pragmatic-programmer/chapter-6"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">🤔 Chapter 6: 동시성 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-topic-28-결합도-줄이기" class="table-of-contents__link">🍭 Topic 28. 결합도 줄이기</a><ul><li><a href="#🥕-열차-사고" class="table-of-contents__link">🥕 열차 사고</a></li><li><a href="#🥕-글로벌화의-해악" class="table-of-contents__link">🥕 글로벌화의 해악</a></li><li><a href="#🥕-상속은-결합을-늘린다" class="table-of-contents__link">🥕 상속은 결합을 늘린다</a></li><li><a href="#🥕-결국은-모두-etc" class="table-of-contents__link">🥕 결국은 모두 ETC</a></li></ul></li><li><a href="#-topic-29-실세계를-갖고-저글링하기" class="table-of-contents__link">🍭 Topic 29. 실세계를 갖고 저글링하기</a><ul><li><a href="#🥕-이벤트" class="table-of-contents__link">🥕 이벤트</a></li><li><a href="#🥕-유한-상태-기계" class="table-of-contents__link">🥕 유한 상태 기계</a></li><li><a href="#🥕-감시자-패턴" class="table-of-contents__link">🥕 감시자 패턴</a></li><li><a href="#🥕-게시-구독" class="table-of-contents__link">🥕 게시-구독</a></li><li><a href="#🥕-반응형-프로그래밍과-스트림-그리고-이벤트" class="table-of-contents__link">🥕 반응형 프로그래밍과 스트림 그리고 이벤트</a></li><li><a href="#🥕-어디에나-이벤트가-있다" class="table-of-contents__link">🥕 어디에나 이벤트가 있다</a></li></ul></li><li><a href="#-topic-30-변환-프로그래밍" class="table-of-contents__link">🍭 Topic 30. 변환 프로그래밍</a><ul><li><a href="#🥕-변환-찾기" class="table-of-contents__link">🥕 변환 찾기</a></li><li><a href="#🥕-이것이-왜-그리-대단한가" class="table-of-contents__link">🥕 이것이 왜 그리 대단한가?</a></li><li><a href="#🥕-오류-처리는-어떻게-하나" class="table-of-contents__link">🥕 오류 처리는 어떻게 하나.</a></li><li><a href="#🥕-변환은-프로그래밍을-변환한다" class="table-of-contents__link">🥕 변환은 프로그래밍을 변환한다</a></li></ul></li><li><a href="#-topic-31-상속세" class="table-of-contents__link">🍭 Topic 31. 상속세</a><ul><li><a href="#🥕-약간의-배경지식" class="table-of-contents__link">🥕 약간의 배경지식</a></li><li><a href="#🥕-코드를-공유하기-위해-상속을-쓸-때의-문제" class="table-of-contents__link">🥕 코드를 공유하기 위해 상속을 쓸 때의 문제</a></li><li><a href="#🥕-타입을-정의하기-위해-상속을-쓸-때의-문제" class="table-of-contents__link">🥕 타입을 정의하기 위해 상속을 쓸 때의 문제</a></li><li><a href="#🥕-더-나은-대안" class="table-of-contents__link">🥕 더 나은 대안</a></li><li><a href="#🥕-상속이-답인-경우는-드물다" class="table-of-contents__link">🥕 상속이 답인 경우는 드물다</a></li></ul></li><li><a href="#-topic-32-설정" class="table-of-contents__link">🍭 Topic 32. 설정</a><ul><li><a href="#🥕-정적-설정" class="table-of-contents__link">🥕 정적 설정</a></li><li><a href="#🥕-서비스형-설정" class="table-of-contents__link">🥕 서비스형 설정</a></li><li><a href="#🥕-도도-코드를-작성하지-말라" class="table-of-contents__link">🥕 도도 코드를 작성하지 말라</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/javascript/table-of-contents">자바스크립트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/typescript/table-of-contents">타입스크립트</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/agile/table-of-contents">애자일</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/object-oriented/table-of-contents">객체지향</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/functional/table-of-contents">함수형</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/clean/table-of-contents">클린코드</a></li><li class="footer__item"><a class="footer__link-item" href="/reading_books_record_repository/docs/etc/table-of-contents">기타</a></li></ul></div><div class="col footer__col"><div class="footer__title">Link</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/saseungmin" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://haranglog.tistory.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="mailto:dbd02169@naver.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>E-mail<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.facebook.com/saseungmin95" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/saseungmin/reading_books_record_repository/tree/master/summarize_books_in_markdown" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github Markdown에서 보기<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/saseungmin/reading_books_record_repository" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub Repository<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Summary of Books, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/reading_books_record_repository/assets/js/runtime~main.11139799.js"></script>
<script src="/reading_books_record_repository/assets/js/main.b15cc5fb.js"></script>
</body>
</html>